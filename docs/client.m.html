<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>client API documentation</title>
    <meta name="description" content="Copyright (c) 2016-2017 Wind River Systems, Inc.

Licensed under the Apache License, Version 2.0 (th..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#client.DEFAULT_CONFIG_DIR">DEFAULT_CONFIG_DIR</a></li>
    <li class="mono"><a href="#client.DEFAULT_CONFIG_FILE">DEFAULT_CONFIG_FILE</a></li>
    <li class="mono"><a href="#client.DEFAULT_KEEP_ALIVE">DEFAULT_KEEP_ALIVE</a></li>
    <li class="mono"><a href="#client.DEFAULT_LOOP_TIME">DEFAULT_LOOP_TIME</a></li>
    <li class="mono"><a href="#client.DEFAULT_THREAD_COUNT">DEFAULT_THREAD_COUNT</a></li>
    <li class="mono"><a href="#client.STATUS_NOT_FOUND">STATUS_NOT_FOUND</a></li>
    <li class="mono"><a href="#client.STATUS_SUCCESS">STATUS_SUCCESS</a></li>
    <li class="mono"><a href="#client.WORK_PUBLISH">WORK_PUBLISH</a></li>
  </ul>

    </li>


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#client.Client">Client</a></span>
        
          
  <ul>
    <li class="mono"><a href="#client.Client.__init__">__init__</a></li>
    <li class="mono"><a href="#client.Client.action_acknowledge">action_acknowledge</a></li>
    <li class="mono"><a href="#client.Client.action_deregister">action_deregister</a></li>
    <li class="mono"><a href="#client.Client.action_progress_update">action_progress_update</a></li>
    <li class="mono"><a href="#client.Client.action_register_callback">action_register_callback</a></li>
    <li class="mono"><a href="#client.Client.action_register_command">action_register_command</a></li>
    <li class="mono"><a href="#client.Client.alarm_publish">alarm_publish</a></li>
    <li class="mono"><a href="#client.Client.attribute_publish">attribute_publish</a></li>
    <li class="mono"><a href="#client.Client.attribute_read_last_sample">attribute_read_last_sample</a></li>
    <li class="mono"><a href="#client.Client.connect">connect</a></li>
    <li class="mono"><a href="#client.Client.diag_ping">diag_ping</a></li>
    <li class="mono"><a href="#client.Client.diag_time">diag_time</a></li>
    <li class="mono"><a href="#client.Client.disconnect">disconnect</a></li>
    <li class="mono"><a href="#client.Client.event_publish">event_publish</a></li>
    <li class="mono"><a href="#client.Client.file_download">file_download</a></li>
    <li class="mono"><a href="#client.Client.file_upload">file_upload</a></li>
    <li class="mono"><a href="#client.Client.initialize">initialize</a></li>
    <li class="mono"><a href="#client.Client.is_alive">is_alive</a></li>
    <li class="mono"><a href="#client.Client.is_connected">is_connected</a></li>
    <li class="mono"><a href="#client.Client.location_publish">location_publish</a></li>
    <li class="mono"><a href="#client.Client.log_level">log_level</a></li>
    <li class="mono"><a href="#client.Client.telemetry_publish">telemetry_publish</a></li>
    <li class="mono"><a href="#client.Client.telemetry_read_last_sample">telemetry_read_last_sample</a></li>
    <li class="mono"><a href="#client.Client.update_thing_details">update_thing_details</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">client</span> module</h1>
  <p>Copyright (c) 2016-2017 Wind River Systems, Inc.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at:
http://www.apache.org/licenses/LICENSE-2.0</p>
<p>Unless required by applicable law or agreed to in writing, software  distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client', this);">Show source &equiv;</a></p>
  <div id="source-client" class="source">
    <pre><code>'''
    Copyright (c) 2016-2017 Wind River Systems, Inc.
    
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at:
    http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software  distributed
    under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
    OR CONDITIONS OF ANY KIND, either express or implied.
'''

"""
This module contains the Client class for user applications
"""

import certifi
import json
import os
import uuid

from device_cloud._core.constants import DEFAULT_CONFIG_DIR
from device_cloud._core.constants import DEFAULT_CONFIG_FILE
from device_cloud._core.constants import DEFAULT_KEEP_ALIVE
from device_cloud._core.constants import DEFAULT_LOOP_TIME
from device_cloud._core.constants import DEFAULT_THREAD_COUNT
from device_cloud._core.constants import STATUS_SUCCESS
from device_cloud._core.constants import WORK_PUBLISH
from device_cloud._core.constants import STATUS_NOT_FOUND
from device_cloud._core import defs
from device_cloud._core.handler import Handler
from device_cloud.identity import Identity


class Client(object):
    """
    This class is used by apps to connect to and communicate with the HDC Cloud

    Logging Functions:
        critical(message)
        debug(message)
        error(message)
        info(message)
        log(log_level, message)
        warning(message)
    """

    def __init__(self, app_id, kwargs=None, offline=False, error_handler=None):
        """
        Start configuration of client. Configuration file location and name can
        be updated after this if necessary. MUST be followed by
        client.initialize() before anything else can be done.

        Parameters:
          app_id              (string) ID of application that will be used to
                                       generate a key. Also used as part of
                                       default configuration file
                                       {APP_ID}-connect.cfg. Maximum 27
                                       characters.
          kwargs                (dict) Optional dict to override any
                                       configuration values. These can also be
                                       overridden individually later.
        """

        # Setup default config structure and file location
        self.config = defs.Config()

        self.offline = offline
        if self.offline:
            print("Warning: running in offline mode")

        default_config = {
            "app_id":app_id,
            "config_dir":DEFAULT_CONFIG_DIR,
            "config_file":DEFAULT_CONFIG_FILE.format(app_id),
            "cloud":{},
            "proxy":{}
        }


        self.config.update(default_config)

        # Override config defaults with any passed values
        if kwargs:
            self.config.update(kwargs)

        self.identity = Identity()

        # Add sleep for idle loop
        # default is 0.1
        self.idle_sleep = 0.1

        # Client notification handler for reply errors
        # 3 parameters: error list, sent_message, reply
        self.error_handler = error_handler

    def initialize(self):
        """
        Finish client setup by reading config files using any config values
        already set, and initializing the client handler. This is required
        before connection can be attempted.

        Returns:
          STATUS_SUCCESS               Configuration completed successfully
          Exception                    Error in configuration
        """

        # Read JSON from config file. Does not overwrite any configuration set
        # in application.
        kwargs = {}
        config_path = os.path.join(self.config.config_dir, self.config.config_file)
        if os.path.exists(config_path):
            try:
                with open(config_path, "r") as config_file:
                    kwargs.update(json.load(config_file))
            except IOError as error:
                print("Error parsing JSON from "
                        "{}".format(self.config.config_file))
                raise error
        else:
            print("Cannot find {}".format(self.config.config_file))
            raise IOError("Cannot find {}".format(self.config.config_file))
        self.config.update(kwargs, False)

        kwargs = {}
        # Check config directory for device_id. If it does not exist, generate a
        # uuid and write it to device_id.
        device_id_path = os.path.join(self.config.config_dir, "device_id")
        if os.path.exists(device_id_path):
            try:
                with open(device_id_path, "r") as id_file:
                    self.config.device_id = id_file.read().strip()
            except:
                print("Failed to read device_id")
                raise IOError("Failed to read device_id")
        else:
            try:
                with open(device_id_path, "w") as id_file:
                    self.config.device_id = self.identity.get_device_id()
                    id_file.write(self.config.device_id)
            except:
                print("Failed to write device_id")
                raise IOError("Failed to write device_id")
        self.config.update(kwargs, False)

        # Check that all necessary configuration has been obtained
        if not self.config.cloud.token:
            print("Cloud token not set. Must be set in config")
            raise KeyError("Cloud token not set. Must be set in config")
        if not self.config.cloud.host:
            print("Cloud host addess not set. Must be set in config")
            raise KeyError("Cloud host address not set. Must be set in config")
        if not self.config.cloud.port:
            print("Cloud port not set. Must be set in config")
            raise KeyError("Cloud port not set. Must be set in config")

        # Generate key
        if self.config.app_id and self.config.device_id:
            self.config.key = "{}-{}".format(self.config.device_id,
                                             self.config.app_id)
        else:
            print("app_id or device_id not set. Required for key.")
            raise KeyError("app_id or device_id not set. Required for key.")

        if len(self.config.key) > 64:
            print("Key exceeds 64 bytes. Please specify an app_id under {} "
                  "bytes in length".format(64-len(self.config.device_id)))
            raise KeyError("Key exceeds 64 bytes. Please specify an app_id "
                           "under {} bytes in length".format(
                               64-len(self.config.device_id)))

        # Final precedence config defaults
        config_defaults = {
            "keep_alive":DEFAULT_KEEP_ALIVE,
            "loop_time":DEFAULT_LOOP_TIME,
            "thread_count":DEFAULT_THREAD_COUNT,
            "ca_bundle_file":certifi.where()
        }
        self.config.update(config_defaults, False)

        # Initialize handler
        self.handler = Handler(self.config, self)

        # Access logger functions
        self.critical = self.handler.logger.critical
        self.debug = self.handler.logger.debug
        self.error = self.handler.logger.error
        self.info = self.handler.logger.info
        self.log = self.handler.logger.log
        self.warning = self.handler.logger.warning

        return STATUS_SUCCESS


    def action_acknowledge(self, request_id, error_code=0, error_message=""):
        """
        Send an acknowledgement for an action request
        Intended for internal use only

        Parameters:
          request_id          (string) If action_request.request_id was
                                       retreived from an action callback, it can
                                       be used here
          error_code             (int) Error code produced by the action
          error_message       (string) Error message to accompany the error code

        Returns:
          STATUS_SUCCESS               Sent acknowledgement for action request
          STATUS_FAILURE               Failed to send acknowledgement of action
                                       request
        """

        ret = None
        if not self.offline:
            ret = self.handler.action_acknowledge(request_id,
                                               error_code,
                                               error_message)
        return ret

    def action_progress_update(self, request_id, message):
        """
        Update message for an action request from the Cloud

        Parameters:
          request_id          (string) If action_request.request_id was
                                       retreived from an action callback, it can
                                       be used here
          message             (string) New message for Cloud request

        Returns:
          STATUS_SUCCESS               Sent progress update for action request
          STATUS_FAILURE               Failed to update progress of action
                                       request
        """
        ret = None
        if not self.offline:
            ret = self.handler.action_progress_update(request_id, message)
        return ret


    def action_deregister(self, action_name):
        """
        Dissociates a Cloud action action from any command or callback

        Parameters:
          action_name         (string) Action to deregister

        Returns:
          STATUS_NOT_FOUND             No action with that name registered
          STATUS_SUCCESS               Action deregistered
        """

        return self.handler.action_deregister(action_name)

    def action_register_callback(self, action_name, callback_function,
                                 user_data=None):
        """
        Associate a callback function with an action in the Cloud

        Parameters:
          action_name         (string) Action to register
          callback_function     (func) Function to execute when triggered by
                                       action. Callback function must take
                                       parameters of the form (client,
                                       parameters, user_data[, action_request])
                                       where action_request is optional, but
                                       contains the request_id for later use.
                                       The callback function must also return
                                       status_code, or (status_code,
                                       status_message) in a tuple.

        Returns:
          STATUS_EXISTS                Action with that name already exists
          STATUS_SUCCESS               Successfully registered callback
        """
        return self.handler.action_register_callback(action_name,
                                                     callback_function,
                                                     user_data)

    def action_register_command(self, action_name, command):
        """
        Associate a console command with an action in the Cloud

        Parameters:
          action_name         (string) Action to register
          command             (string) Console command to execute when
                                       triggered by action
        Returns:
          STATUS_EXISTS                Action with that name already exists
          STATUS_SUCCESS               Successfully registered command
        """

        return self.handler.action_register_command(action_name, command)

    def alarm_publish(self, alarm_name, state, message=None, republish=False):
        """
        Publish an alarm to the Cloud

        Parameters:
          alarm_name          (string) Name of alarm to publish
          state                  (int) State of publish
          message             (string) Optional message to accompany alarm

        Returns:
          STATUS_SUCCESS               Alarm has been queued for publishing
        """

        ret = None
        if not self.offline:
            alarm = defs.PublishAlarm(alarm_name, state, message, republish)
            self.handler.queue_publish(alarm)
            work = defs.Work(WORK_PUBLISH, None)
            ret =  self.handler.queue_work(work)
        return ret

    def attribute_publish(self, attribute_name, value):
        """
        Publish string telemetry to the Cloud

        Parameters:
          attribute_name      (string) Key of the attribute to publish
          value               (string) Value to publish

        Returns:
          STATUS_SUCCESS               Attribute has been queued for publishing
        """

        attr = defs.PublishAttribute(attribute_name, value)
        return self.handler.queue_publish(attr)

    def connect(self, timeout=0):
        """
        Connect the Client to the Cloud

        Parameters:
          timeout             (number) Maximum time to try to connect

        Returns:
          STATUS_FAILURE               Failed to connect to Cloud
          STATUS_SUCCESS               Successfully connected to Cloud
          STATUS_TIMED_OUT             Connection attempt timed out
        """

        return self.handler.connect(timeout)

    def disconnect(self, wait_for_replies=False, timeout=0):
        """
        End Client connection to the Cloud

        Parameters:
          wait_for_replies      (bool) When True, wait for any pending replies
                                       to be received or time out before
                                       disconnecting
          timeout             (number) Maximum time to wait before returning

        Returns:
          STATUS_SUCCESS               Successfully disconnected
        """

        return self.handler.disconnect(wait_for_replies=wait_for_replies,
                                       timeout=timeout)

    def diag_ping(self):
        """
        Request diagonstic ping from the cloud

        Returns:
          STATUS_SUCCESS               True
        """
        return self.handler.handle_ping()

    def diag_time(self):
        """
        Request diagonstic time from the cloud

        Returns:
          STATUS_SUCCESS               Current cloud time
        """
        return self.handler.handle_time()

    def log_level(self, level):
        """
        Set the log level
        
        Parameters:
          level             (string) Requested level
        """
        return self.handler.log_level(level)

    def event_publish(self, message):
        """
        Publishes an event message to the Cloud

        Parameters:
          message             (string) Message to publish

        Returns:
          STATUS_SUCCESS               Event has been queued for publishing
        """
        ret = None
        if not self.offline:
            log = defs.PublishLog(message)
            ret = self.handler.queue_publish(log)
        return ret

    def file_download(self, file_name, download_dest, blocking=False,
                      callback=None, timeout=0, file_global=False):
        """
        Download a file from the Cloud to the device (C2D)

        Parameters:
          file_name           (string) File in Cloud to download
          download_dest       (string) Destination for downloaded file
          blocking              (bool) Wait for file transfer to complete
                                       before returning. Otherwise return
                                       immediately.
          callback              (func) Function to be executed as soon as file
                                       transfer is complete. It will be passed
                                       (client, file_name, status).
          timeout             (number) If blocking, maximum time to wait
                                       before returning
          file_global                  Flag that indicates whether or not the
                                       file to download is in the global file
                                       store or the thing's file store

        Returns:
          STATUS_FAILURE               Failed to download file.
          STATUS_NOT_FOUND             Could not find download directory to
                                       download file to.
          STATUS_SUCCESS               File download successful
          STATUS_TIMED_OUT             Wait for file transfer timed out. File
                                       transfer is still in progress.
        """

        return self.handler.request_download(file_name, download_dest, blocking,
                                             callback, timeout, file_global)

    def file_upload(self, file_path, upload_name=None, blocking=False,
                    callback=None, timeout=0, file_global=False):
        """
        Upload a file from the device to the Cloud (D2C)

        Parameters:
          file_path           (string) Absolute path for file to upload.
          upload_name         (string) Name for file uploaded in Cloud.
                                       Default is the file name on the device.
          blocking              (bool) Wait for file transfer to complete
                                       before returning. Otherwise return
                                       immediately.
          callback              (func) Function to be executed as soon as file
                                       transfer is complete. It will be passed
                                       (client, file_name, status).
          timeout             (number) If blocking, maximum time to wait
                                       before returning
          file_global                  Flag that indicates whether or not the
                                       file should be uploaded to the global
                                       file store or the thing's file store

        Returns:
          STATUS_FAILURE               Failed to upload file.
          STATUS_NOT_FOUND             Could not find find to upload in upload
                                       directory.
          STATUS_SUCCESS               File upload successful
          STATUS_TIMED_OUT             Wait for file transfer timed out. File
                                       transfer is still in progress.
        """
        ret = None
        if not self.offline:
            if os.path.isdir(file_path):
                result = []
                for fn in os.listdir(file_path):
                    result.append(self.handler.request_upload((file_path+os.sep+fn), fn, blocking,
                                               callback, timeout, file_global))
                if not result:
                    return STATUS_NOT_FOUND
                return max(result)
            ret = self.handler.request_upload(file_path, upload_name, blocking,
                                              callback, timeout, file_global)
        return ret

    def is_alive(self):
        """
        Return whether or not the Client has exited

        Returns:
          True                         Client is running
          False                        Client is not running
        """

        return not self.handler.to_quit

    def is_connected(self):
        """
        Return the current connect status of the Client

        Returns:
          True                         Connected to Cloud
          False                        Not connected to Cloud
        """

        return self.handler.is_connected()

    def location_publish(self, latitude, longitude, heading=None, altitude=None,
                         speed=None, accuracy=None, fix_type=None):
        """
        Publish a location metric to the Cloud

        Parameters:
          latitude            (number) Latitude coordinate
          longitude           (number) Longitude coordinate
          heading             (number) Heading
          altitude            (number) Altitude
          speed               (number) Speed
          accuracy            (number) Accuracy of fix
          fix_type            (string) Fix type

        Returns:
          STATUS_SUCCESS               Location has been queued for publishing
        """

        location = defs.PublishLocation(latitude, longitude, heading=heading,
                                        altitude=altitude, speed=speed,
                                        accuracy=accuracy, fix_type=fix_type)
        return self.handler.queue_publish(location)

    def telemetry_publish(self, telemetry_name, value, cloud_response=False, timestamp=None):
        """
        Publish telemetry to the Cloud

        Parameters:
          telemetry_name      (string) Key of property to publish
          value               (number) Value to publish
          cloud_response      (bool) Wait for response from cloud
                                     If true, the return status indicates if
                                     it was sent to the cloud. Otherwise,
                                     the return status is if it was queued.
          timestamp           (string) Optional datetime format timestamp to
                                       override the timestamp applied by the API
        Returns:
          STATUS_SUCCESS             Telemetry has been queued for publishing
        """

        telem = defs.PublishTelemetry(telemetry_name, value, timestamp)
        return self.handler.request_publish(telem, cloud_response)

    def telemetry_read_last_sample(self, telemetry_name):
        """
        Read back last/current telemetry sample from the Cloud

        Parameters
          telemetry_name      (string) Key of property to publish

        Returns:
          STATUS_SUCCESS               Telemetry has been queued for publishing
          value                        Value for last telemetry sample in cloud
          timestamp                    Timestamp for the sample
        """

        return self.handler.handle_telemetry_get(telemetry_name)

    def attribute_read_last_sample(self, attribute_name):
        """
        Read back last/current attribute sample from the Cloud

        Parameters
          attribute_name      (string) Key of property to publish

        Returns:
          STATUS_SUCCESS               Telemetry has been queued for publishing
          value                        Value for last attribute sample in cloud
          timestamp                    Timestamp for the sample
        """

        return self.handler.handle_attribute_get(attribute_name)

    def update_thing_details(self, name=None, description=None,
                             iccid=None, esn=None, imei=None, meid=None,
                             imsi=None, unset_fields=[]):
        """
        Update a things description.  All fields are optional, if none
        are specified, then the action is a noop.

        Parameters:
            name              (string) Friendly name.
            description       (string) Description of thing.
            iccid             (string) ICCID
            esn               (string) ESN
            imei              (string) IMEI
            meid              (string) MEID
            imsi              (string) IMSI
            unset_fields      (list) List of field names above to unset.

        Returns:
            STATUS_SUCCESS
        """

        return self.handler.handle_update_thing_details(name, description,
                                    iccid, esn, imei, meid, imsi, unset_fields)
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="client.DEFAULT_CONFIG_DIR" class="name">var <span class="ident">DEFAULT_CONFIG_DIR</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="client.DEFAULT_CONFIG_FILE" class="name">var <span class="ident">DEFAULT_CONFIG_FILE</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="client.DEFAULT_KEEP_ALIVE" class="name">var <span class="ident">DEFAULT_KEEP_ALIVE</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="client.DEFAULT_LOOP_TIME" class="name">var <span class="ident">DEFAULT_LOOP_TIME</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="client.DEFAULT_THREAD_COUNT" class="name">var <span class="ident">DEFAULT_THREAD_COUNT</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="client.STATUS_NOT_FOUND" class="name">var <span class="ident">STATUS_NOT_FOUND</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="client.STATUS_SUCCESS" class="name">var <span class="ident">STATUS_SUCCESS</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="client.WORK_PUBLISH" class="name">var <span class="ident">WORK_PUBLISH</span></p>
      
  
  <div class="source_cont">
</div>

      </div>


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="client.Client" class="name">class <span class="ident">Client</span></p>
      
  
    <div class="desc"><p>This class is used by apps to connect to and communicate with the HDC Cloud</p>
<p>Logging Functions:
    critical(message)
    debug(message)
    error(message)
    info(message)
    log(log_level, message)
    warning(message)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client', this);">Show source &equiv;</a></p>
  <div id="source-client.Client" class="source">
    <pre><code>class Client(object):
    """
    This class is used by apps to connect to and communicate with the HDC Cloud

    Logging Functions:
        critical(message)
        debug(message)
        error(message)
        info(message)
        log(log_level, message)
        warning(message)
    """

    def __init__(self, app_id, kwargs=None, offline=False, error_handler=None):
        """
        Start configuration of client. Configuration file location and name can
        be updated after this if necessary. MUST be followed by
        client.initialize() before anything else can be done.

        Parameters:
          app_id              (string) ID of application that will be used to
                                       generate a key. Also used as part of
                                       default configuration file
                                       {APP_ID}-connect.cfg. Maximum 27
                                       characters.
          kwargs                (dict) Optional dict to override any
                                       configuration values. These can also be
                                       overridden individually later.
        """

        # Setup default config structure and file location
        self.config = defs.Config()

        self.offline = offline
        if self.offline:
            print("Warning: running in offline mode")

        default_config = {
            "app_id":app_id,
            "config_dir":DEFAULT_CONFIG_DIR,
            "config_file":DEFAULT_CONFIG_FILE.format(app_id),
            "cloud":{},
            "proxy":{}
        }


        self.config.update(default_config)

        # Override config defaults with any passed values
        if kwargs:
            self.config.update(kwargs)

        self.identity = Identity()

        # Add sleep for idle loop
        # default is 0.1
        self.idle_sleep = 0.1

        # Client notification handler for reply errors
        # 3 parameters: error list, sent_message, reply
        self.error_handler = error_handler

    def initialize(self):
        """
        Finish client setup by reading config files using any config values
        already set, and initializing the client handler. This is required
        before connection can be attempted.

        Returns:
          STATUS_SUCCESS               Configuration completed successfully
          Exception                    Error in configuration
        """

        # Read JSON from config file. Does not overwrite any configuration set
        # in application.
        kwargs = {}
        config_path = os.path.join(self.config.config_dir, self.config.config_file)
        if os.path.exists(config_path):
            try:
                with open(config_path, "r") as config_file:
                    kwargs.update(json.load(config_file))
            except IOError as error:
                print("Error parsing JSON from "
                        "{}".format(self.config.config_file))
                raise error
        else:
            print("Cannot find {}".format(self.config.config_file))
            raise IOError("Cannot find {}".format(self.config.config_file))
        self.config.update(kwargs, False)

        kwargs = {}
        # Check config directory for device_id. If it does not exist, generate a
        # uuid and write it to device_id.
        device_id_path = os.path.join(self.config.config_dir, "device_id")
        if os.path.exists(device_id_path):
            try:
                with open(device_id_path, "r") as id_file:
                    self.config.device_id = id_file.read().strip()
            except:
                print("Failed to read device_id")
                raise IOError("Failed to read device_id")
        else:
            try:
                with open(device_id_path, "w") as id_file:
                    self.config.device_id = self.identity.get_device_id()
                    id_file.write(self.config.device_id)
            except:
                print("Failed to write device_id")
                raise IOError("Failed to write device_id")
        self.config.update(kwargs, False)

        # Check that all necessary configuration has been obtained
        if not self.config.cloud.token:
            print("Cloud token not set. Must be set in config")
            raise KeyError("Cloud token not set. Must be set in config")
        if not self.config.cloud.host:
            print("Cloud host addess not set. Must be set in config")
            raise KeyError("Cloud host address not set. Must be set in config")
        if not self.config.cloud.port:
            print("Cloud port not set. Must be set in config")
            raise KeyError("Cloud port not set. Must be set in config")

        # Generate key
        if self.config.app_id and self.config.device_id:
            self.config.key = "{}-{}".format(self.config.device_id,
                                             self.config.app_id)
        else:
            print("app_id or device_id not set. Required for key.")
            raise KeyError("app_id or device_id not set. Required for key.")

        if len(self.config.key) > 64:
            print("Key exceeds 64 bytes. Please specify an app_id under {} "
                  "bytes in length".format(64-len(self.config.device_id)))
            raise KeyError("Key exceeds 64 bytes. Please specify an app_id "
                           "under {} bytes in length".format(
                               64-len(self.config.device_id)))

        # Final precedence config defaults
        config_defaults = {
            "keep_alive":DEFAULT_KEEP_ALIVE,
            "loop_time":DEFAULT_LOOP_TIME,
            "thread_count":DEFAULT_THREAD_COUNT,
            "ca_bundle_file":certifi.where()
        }
        self.config.update(config_defaults, False)

        # Initialize handler
        self.handler = Handler(self.config, self)

        # Access logger functions
        self.critical = self.handler.logger.critical
        self.debug = self.handler.logger.debug
        self.error = self.handler.logger.error
        self.info = self.handler.logger.info
        self.log = self.handler.logger.log
        self.warning = self.handler.logger.warning

        return STATUS_SUCCESS


    def action_acknowledge(self, request_id, error_code=0, error_message=""):
        """
        Send an acknowledgement for an action request
        Intended for internal use only

        Parameters:
          request_id          (string) If action_request.request_id was
                                       retreived from an action callback, it can
                                       be used here
          error_code             (int) Error code produced by the action
          error_message       (string) Error message to accompany the error code

        Returns:
          STATUS_SUCCESS               Sent acknowledgement for action request
          STATUS_FAILURE               Failed to send acknowledgement of action
                                       request
        """

        ret = None
        if not self.offline:
            ret = self.handler.action_acknowledge(request_id,
                                               error_code,
                                               error_message)
        return ret

    def action_progress_update(self, request_id, message):
        """
        Update message for an action request from the Cloud

        Parameters:
          request_id          (string) If action_request.request_id was
                                       retreived from an action callback, it can
                                       be used here
          message             (string) New message for Cloud request

        Returns:
          STATUS_SUCCESS               Sent progress update for action request
          STATUS_FAILURE               Failed to update progress of action
                                       request
        """
        ret = None
        if not self.offline:
            ret = self.handler.action_progress_update(request_id, message)
        return ret


    def action_deregister(self, action_name):
        """
        Dissociates a Cloud action action from any command or callback

        Parameters:
          action_name         (string) Action to deregister

        Returns:
          STATUS_NOT_FOUND             No action with that name registered
          STATUS_SUCCESS               Action deregistered
        """

        return self.handler.action_deregister(action_name)

    def action_register_callback(self, action_name, callback_function,
                                 user_data=None):
        """
        Associate a callback function with an action in the Cloud

        Parameters:
          action_name         (string) Action to register
          callback_function     (func) Function to execute when triggered by
                                       action. Callback function must take
                                       parameters of the form (client,
                                       parameters, user_data[, action_request])
                                       where action_request is optional, but
                                       contains the request_id for later use.
                                       The callback function must also return
                                       status_code, or (status_code,
                                       status_message) in a tuple.

        Returns:
          STATUS_EXISTS                Action with that name already exists
          STATUS_SUCCESS               Successfully registered callback
        """
        return self.handler.action_register_callback(action_name,
                                                     callback_function,
                                                     user_data)

    def action_register_command(self, action_name, command):
        """
        Associate a console command with an action in the Cloud

        Parameters:
          action_name         (string) Action to register
          command             (string) Console command to execute when
                                       triggered by action
        Returns:
          STATUS_EXISTS                Action with that name already exists
          STATUS_SUCCESS               Successfully registered command
        """

        return self.handler.action_register_command(action_name, command)

    def alarm_publish(self, alarm_name, state, message=None, republish=False):
        """
        Publish an alarm to the Cloud

        Parameters:
          alarm_name          (string) Name of alarm to publish
          state                  (int) State of publish
          message             (string) Optional message to accompany alarm

        Returns:
          STATUS_SUCCESS               Alarm has been queued for publishing
        """

        ret = None
        if not self.offline:
            alarm = defs.PublishAlarm(alarm_name, state, message, republish)
            self.handler.queue_publish(alarm)
            work = defs.Work(WORK_PUBLISH, None)
            ret =  self.handler.queue_work(work)
        return ret

    def attribute_publish(self, attribute_name, value):
        """
        Publish string telemetry to the Cloud

        Parameters:
          attribute_name      (string) Key of the attribute to publish
          value               (string) Value to publish

        Returns:
          STATUS_SUCCESS               Attribute has been queued for publishing
        """

        attr = defs.PublishAttribute(attribute_name, value)
        return self.handler.queue_publish(attr)

    def connect(self, timeout=0):
        """
        Connect the Client to the Cloud

        Parameters:
          timeout             (number) Maximum time to try to connect

        Returns:
          STATUS_FAILURE               Failed to connect to Cloud
          STATUS_SUCCESS               Successfully connected to Cloud
          STATUS_TIMED_OUT             Connection attempt timed out
        """

        return self.handler.connect(timeout)

    def disconnect(self, wait_for_replies=False, timeout=0):
        """
        End Client connection to the Cloud

        Parameters:
          wait_for_replies      (bool) When True, wait for any pending replies
                                       to be received or time out before
                                       disconnecting
          timeout             (number) Maximum time to wait before returning

        Returns:
          STATUS_SUCCESS               Successfully disconnected
        """

        return self.handler.disconnect(wait_for_replies=wait_for_replies,
                                       timeout=timeout)

    def diag_ping(self):
        """
        Request diagonstic ping from the cloud

        Returns:
          STATUS_SUCCESS               True
        """
        return self.handler.handle_ping()

    def diag_time(self):
        """
        Request diagonstic time from the cloud

        Returns:
          STATUS_SUCCESS               Current cloud time
        """
        return self.handler.handle_time()

    def log_level(self, level):
        """
        Set the log level
        
        Parameters:
          level             (string) Requested level
        """
        return self.handler.log_level(level)

    def event_publish(self, message):
        """
        Publishes an event message to the Cloud

        Parameters:
          message             (string) Message to publish

        Returns:
          STATUS_SUCCESS               Event has been queued for publishing
        """
        ret = None
        if not self.offline:
            log = defs.PublishLog(message)
            ret = self.handler.queue_publish(log)
        return ret

    def file_download(self, file_name, download_dest, blocking=False,
                      callback=None, timeout=0, file_global=False):
        """
        Download a file from the Cloud to the device (C2D)

        Parameters:
          file_name           (string) File in Cloud to download
          download_dest       (string) Destination for downloaded file
          blocking              (bool) Wait for file transfer to complete
                                       before returning. Otherwise return
                                       immediately.
          callback              (func) Function to be executed as soon as file
                                       transfer is complete. It will be passed
                                       (client, file_name, status).
          timeout             (number) If blocking, maximum time to wait
                                       before returning
          file_global                  Flag that indicates whether or not the
                                       file to download is in the global file
                                       store or the thing's file store

        Returns:
          STATUS_FAILURE               Failed to download file.
          STATUS_NOT_FOUND             Could not find download directory to
                                       download file to.
          STATUS_SUCCESS               File download successful
          STATUS_TIMED_OUT             Wait for file transfer timed out. File
                                       transfer is still in progress.
        """

        return self.handler.request_download(file_name, download_dest, blocking,
                                             callback, timeout, file_global)

    def file_upload(self, file_path, upload_name=None, blocking=False,
                    callback=None, timeout=0, file_global=False):
        """
        Upload a file from the device to the Cloud (D2C)

        Parameters:
          file_path           (string) Absolute path for file to upload.
          upload_name         (string) Name for file uploaded in Cloud.
                                       Default is the file name on the device.
          blocking              (bool) Wait for file transfer to complete
                                       before returning. Otherwise return
                                       immediately.
          callback              (func) Function to be executed as soon as file
                                       transfer is complete. It will be passed
                                       (client, file_name, status).
          timeout             (number) If blocking, maximum time to wait
                                       before returning
          file_global                  Flag that indicates whether or not the
                                       file should be uploaded to the global
                                       file store or the thing's file store

        Returns:
          STATUS_FAILURE               Failed to upload file.
          STATUS_NOT_FOUND             Could not find find to upload in upload
                                       directory.
          STATUS_SUCCESS               File upload successful
          STATUS_TIMED_OUT             Wait for file transfer timed out. File
                                       transfer is still in progress.
        """
        ret = None
        if not self.offline:
            if os.path.isdir(file_path):
                result = []
                for fn in os.listdir(file_path):
                    result.append(self.handler.request_upload((file_path+os.sep+fn), fn, blocking,
                                               callback, timeout, file_global))
                if not result:
                    return STATUS_NOT_FOUND
                return max(result)
            ret = self.handler.request_upload(file_path, upload_name, blocking,
                                              callback, timeout, file_global)
        return ret

    def is_alive(self):
        """
        Return whether or not the Client has exited

        Returns:
          True                         Client is running
          False                        Client is not running
        """

        return not self.handler.to_quit

    def is_connected(self):
        """
        Return the current connect status of the Client

        Returns:
          True                         Connected to Cloud
          False                        Not connected to Cloud
        """

        return self.handler.is_connected()

    def location_publish(self, latitude, longitude, heading=None, altitude=None,
                         speed=None, accuracy=None, fix_type=None):
        """
        Publish a location metric to the Cloud

        Parameters:
          latitude            (number) Latitude coordinate
          longitude           (number) Longitude coordinate
          heading             (number) Heading
          altitude            (number) Altitude
          speed               (number) Speed
          accuracy            (number) Accuracy of fix
          fix_type            (string) Fix type

        Returns:
          STATUS_SUCCESS               Location has been queued for publishing
        """

        location = defs.PublishLocation(latitude, longitude, heading=heading,
                                        altitude=altitude, speed=speed,
                                        accuracy=accuracy, fix_type=fix_type)
        return self.handler.queue_publish(location)

    def telemetry_publish(self, telemetry_name, value, cloud_response=False, timestamp=None):
        """
        Publish telemetry to the Cloud

        Parameters:
          telemetry_name      (string) Key of property to publish
          value               (number) Value to publish
          cloud_response      (bool) Wait for response from cloud
                                     If true, the return status indicates if
                                     it was sent to the cloud. Otherwise,
                                     the return status is if it was queued.
          timestamp           (string) Optional datetime format timestamp to
                                       override the timestamp applied by the API
        Returns:
          STATUS_SUCCESS             Telemetry has been queued for publishing
        """

        telem = defs.PublishTelemetry(telemetry_name, value, timestamp)
        return self.handler.request_publish(telem, cloud_response)

    def telemetry_read_last_sample(self, telemetry_name):
        """
        Read back last/current telemetry sample from the Cloud

        Parameters
          telemetry_name      (string) Key of property to publish

        Returns:
          STATUS_SUCCESS               Telemetry has been queued for publishing
          value                        Value for last telemetry sample in cloud
          timestamp                    Timestamp for the sample
        """

        return self.handler.handle_telemetry_get(telemetry_name)

    def attribute_read_last_sample(self, attribute_name):
        """
        Read back last/current attribute sample from the Cloud

        Parameters
          attribute_name      (string) Key of property to publish

        Returns:
          STATUS_SUCCESS               Telemetry has been queued for publishing
          value                        Value for last attribute sample in cloud
          timestamp                    Timestamp for the sample
        """

        return self.handler.handle_attribute_get(attribute_name)

    def update_thing_details(self, name=None, description=None,
                             iccid=None, esn=None, imei=None, meid=None,
                             imsi=None, unset_fields=[]):
        """
        Update a things description.  All fields are optional, if none
        are specified, then the action is a noop.

        Parameters:
            name              (string) Friendly name.
            description       (string) Description of thing.
            iccid             (string) ICCID
            esn               (string) ESN
            imei              (string) IMEI
            meid              (string) MEID
            imsi              (string) IMSI
            unset_fields      (list) List of field names above to unset.

        Returns:
            STATUS_SUCCESS
        """

        return self.handler.handle_update_thing_details(name, description,
                                    iccid, esn, imei, meid, imsi, unset_fields)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#client.Client">Client</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="client.Client.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, app_id, kwargs=None, offline=False, error_handler=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Start configuration of client. Configuration file location and name can
be updated after this if necessary. MUST be followed by
client.initialize() before anything else can be done.</p>
<p>Parameters:
  app_id              (string) ID of application that will be used to
                               generate a key. Also used as part of
                               default configuration file
                               {APP_ID}-connect.cfg. Maximum 27
                               characters.
  kwargs                (dict) Optional dict to override any
                               configuration values. These can also be
                               overridden individually later.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.__init__', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.__init__" class="source">
    <pre><code>def __init__(self, app_id, kwargs=None, offline=False, error_handler=None):
    """
    Start configuration of client. Configuration file location and name can
    be updated after this if necessary. MUST be followed by
    client.initialize() before anything else can be done.
    Parameters:
      app_id              (string) ID of application that will be used to
                                   generate a key. Also used as part of
                                   default configuration file
                                   {APP_ID}-connect.cfg. Maximum 27
                                   characters.
      kwargs                (dict) Optional dict to override any
                                   configuration values. These can also be
                                   overridden individually later.
    """
    # Setup default config structure and file location
    self.config = defs.Config()
    self.offline = offline
    if self.offline:
        print("Warning: running in offline mode")
    default_config = {
        "app_id":app_id,
        "config_dir":DEFAULT_CONFIG_DIR,
        "config_file":DEFAULT_CONFIG_FILE.format(app_id),
        "cloud":{},
        "proxy":{}
    }
    self.config.update(default_config)
    # Override config defaults with any passed values
    if kwargs:
        self.config.update(kwargs)
    self.identity = Identity()
    # Add sleep for idle loop
    # default is 0.1
    self.idle_sleep = 0.1
    # Client notification handler for reply errors
    # 3 parameters: error list, sent_message, reply
    self.error_handler = error_handler
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.action_acknowledge">
    <p>def <span class="ident">action_acknowledge</span>(</p><p>self, request_id, error_code=0, error_message=&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Send an acknowledgement for an action request
Intended for internal use only</p>
<p>Parameters:
  request_id          (string) If action_request.request_id was
                               retreived from an action callback, it can
                               be used here
  error_code             (int) Error code produced by the action
  error_message       (string) Error message to accompany the error code</p>
<p>Returns:
  STATUS_SUCCESS               Sent acknowledgement for action request
  STATUS_FAILURE               Failed to send acknowledgement of action
                               request</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.action_acknowledge', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.action_acknowledge" class="source">
    <pre><code>def action_acknowledge(self, request_id, error_code=0, error_message=""):
    """
    Send an acknowledgement for an action request
    Intended for internal use only
    Parameters:
      request_id          (string) If action_request.request_id was
                                   retreived from an action callback, it can
                                   be used here
      error_code             (int) Error code produced by the action
      error_message       (string) Error message to accompany the error code
    Returns:
      STATUS_SUCCESS               Sent acknowledgement for action request
      STATUS_FAILURE               Failed to send acknowledgement of action
                                   request
    """
    ret = None
    if not self.offline:
        ret = self.handler.action_acknowledge(request_id,
                                           error_code,
                                           error_message)
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.action_deregister">
    <p>def <span class="ident">action_deregister</span>(</p><p>self, action_name)</p>
    </div>
    

    
  
    <div class="desc"><p>Dissociates a Cloud action action from any command or callback</p>
<p>Parameters:
  action_name         (string) Action to deregister</p>
<p>Returns:
  STATUS_NOT_FOUND             No action with that name registered
  STATUS_SUCCESS               Action deregistered</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.action_deregister', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.action_deregister" class="source">
    <pre><code>def action_deregister(self, action_name):
    """
    Dissociates a Cloud action action from any command or callback
    Parameters:
      action_name         (string) Action to deregister
    Returns:
      STATUS_NOT_FOUND             No action with that name registered
      STATUS_SUCCESS               Action deregistered
    """
    return self.handler.action_deregister(action_name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.action_progress_update">
    <p>def <span class="ident">action_progress_update</span>(</p><p>self, request_id, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Update message for an action request from the Cloud</p>
<p>Parameters:
  request_id          (string) If action_request.request_id was
                               retreived from an action callback, it can
                               be used here
  message             (string) New message for Cloud request</p>
<p>Returns:
  STATUS_SUCCESS               Sent progress update for action request
  STATUS_FAILURE               Failed to update progress of action
                               request</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.action_progress_update', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.action_progress_update" class="source">
    <pre><code>def action_progress_update(self, request_id, message):
    """
    Update message for an action request from the Cloud
    Parameters:
      request_id          (string) If action_request.request_id was
                                   retreived from an action callback, it can
                                   be used here
      message             (string) New message for Cloud request
    Returns:
      STATUS_SUCCESS               Sent progress update for action request
      STATUS_FAILURE               Failed to update progress of action
                                   request
    """
    ret = None
    if not self.offline:
        ret = self.handler.action_progress_update(request_id, message)
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.action_register_callback">
    <p>def <span class="ident">action_register_callback</span>(</p><p>self, action_name, callback_function, user_data=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Associate a callback function with an action in the Cloud</p>
<p>Parameters:
  action_name         (string) Action to register
  callback_function     (func) Function to execute when triggered by
                               action. Callback function must take
                               parameters of the form (client,
                               parameters, user_data[, action_request])
                               where action_request is optional, but
                               contains the request_id for later use.
                               The callback function must also return
                               status_code, or (status_code,
                               status_message) in a tuple.</p>
<p>Returns:
  STATUS_EXISTS                Action with that name already exists
  STATUS_SUCCESS               Successfully registered callback</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.action_register_callback', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.action_register_callback" class="source">
    <pre><code>def action_register_callback(self, action_name, callback_function,
                             user_data=None):
    """
    Associate a callback function with an action in the Cloud
    Parameters:
      action_name         (string) Action to register
      callback_function     (func) Function to execute when triggered by
                                   action. Callback function must take
                                   parameters of the form (client,
                                   parameters, user_data[, action_request])
                                   where action_request is optional, but
                                   contains the request_id for later use.
                                   The callback function must also return
                                   status_code, or (status_code,
                                   status_message) in a tuple.
    Returns:
      STATUS_EXISTS                Action with that name already exists
      STATUS_SUCCESS               Successfully registered callback
    """
    return self.handler.action_register_callback(action_name,
                                                 callback_function,
                                                 user_data)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.action_register_command">
    <p>def <span class="ident">action_register_command</span>(</p><p>self, action_name, command)</p>
    </div>
    

    
  
    <div class="desc"><p>Associate a console command with an action in the Cloud</p>
<p>Parameters:
  action_name         (string) Action to register
  command             (string) Console command to execute when
                               triggered by action
Returns:
  STATUS_EXISTS                Action with that name already exists
  STATUS_SUCCESS               Successfully registered command</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.action_register_command', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.action_register_command" class="source">
    <pre><code>def action_register_command(self, action_name, command):
    """
    Associate a console command with an action in the Cloud
    Parameters:
      action_name         (string) Action to register
      command             (string) Console command to execute when
                                   triggered by action
    Returns:
      STATUS_EXISTS                Action with that name already exists
      STATUS_SUCCESS               Successfully registered command
    """
    return self.handler.action_register_command(action_name, command)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.alarm_publish">
    <p>def <span class="ident">alarm_publish</span>(</p><p>self, alarm_name, state, message=None, republish=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Publish an alarm to the Cloud</p>
<p>Parameters:
  alarm_name          (string) Name of alarm to publish
  state                  (int) State of publish
  message             (string) Optional message to accompany alarm</p>
<p>Returns:
  STATUS_SUCCESS               Alarm has been queued for publishing</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.alarm_publish', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.alarm_publish" class="source">
    <pre><code>def alarm_publish(self, alarm_name, state, message=None, republish=False):
    """
    Publish an alarm to the Cloud
    Parameters:
      alarm_name          (string) Name of alarm to publish
      state                  (int) State of publish
      message             (string) Optional message to accompany alarm
    Returns:
      STATUS_SUCCESS               Alarm has been queued for publishing
    """
    ret = None
    if not self.offline:
        alarm = defs.PublishAlarm(alarm_name, state, message, republish)
        self.handler.queue_publish(alarm)
        work = defs.Work(WORK_PUBLISH, None)
        ret =  self.handler.queue_work(work)
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.attribute_publish">
    <p>def <span class="ident">attribute_publish</span>(</p><p>self, attribute_name, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Publish string telemetry to the Cloud</p>
<p>Parameters:
  attribute_name      (string) Key of the attribute to publish
  value               (string) Value to publish</p>
<p>Returns:
  STATUS_SUCCESS               Attribute has been queued for publishing</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.attribute_publish', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.attribute_publish" class="source">
    <pre><code>def attribute_publish(self, attribute_name, value):
    """
    Publish string telemetry to the Cloud
    Parameters:
      attribute_name      (string) Key of the attribute to publish
      value               (string) Value to publish
    Returns:
      STATUS_SUCCESS               Attribute has been queued for publishing
    """
    attr = defs.PublishAttribute(attribute_name, value)
    return self.handler.queue_publish(attr)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.attribute_read_last_sample">
    <p>def <span class="ident">attribute_read_last_sample</span>(</p><p>self, attribute_name)</p>
    </div>
    

    
  
    <div class="desc"><p>Read back last/current attribute sample from the Cloud</p>
<p>Parameters
  attribute_name      (string) Key of property to publish</p>
<p>Returns:
  STATUS_SUCCESS               Telemetry has been queued for publishing
  value                        Value for last attribute sample in cloud
  timestamp                    Timestamp for the sample</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.attribute_read_last_sample', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.attribute_read_last_sample" class="source">
    <pre><code>def attribute_read_last_sample(self, attribute_name):
    """
    Read back last/current attribute sample from the Cloud
    Parameters
      attribute_name      (string) Key of property to publish
    Returns:
      STATUS_SUCCESS               Telemetry has been queued for publishing
      value                        Value for last attribute sample in cloud
      timestamp                    Timestamp for the sample
    """
    return self.handler.handle_attribute_get(attribute_name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.connect">
    <p>def <span class="ident">connect</span>(</p><p>self, timeout=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Connect the Client to the Cloud</p>
<p>Parameters:
  timeout             (number) Maximum time to try to connect</p>
<p>Returns:
  STATUS_FAILURE               Failed to connect to Cloud
  STATUS_SUCCESS               Successfully connected to Cloud
  STATUS_TIMED_OUT             Connection attempt timed out</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.connect', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.connect" class="source">
    <pre><code>def connect(self, timeout=0):
    """
    Connect the Client to the Cloud
    Parameters:
      timeout             (number) Maximum time to try to connect
    Returns:
      STATUS_FAILURE               Failed to connect to Cloud
      STATUS_SUCCESS               Successfully connected to Cloud
      STATUS_TIMED_OUT             Connection attempt timed out
    """
    return self.handler.connect(timeout)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.diag_ping">
    <p>def <span class="ident">diag_ping</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Request diagonstic ping from the cloud</p>
<p>Returns:
  STATUS_SUCCESS               True</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.diag_ping', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.diag_ping" class="source">
    <pre><code>def diag_ping(self):
    """
    Request diagonstic ping from the cloud
    Returns:
      STATUS_SUCCESS               True
    """
    return self.handler.handle_ping()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.diag_time">
    <p>def <span class="ident">diag_time</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Request diagonstic time from the cloud</p>
<p>Returns:
  STATUS_SUCCESS               Current cloud time</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.diag_time', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.diag_time" class="source">
    <pre><code>def diag_time(self):
    """
    Request diagonstic time from the cloud
    Returns:
      STATUS_SUCCESS               Current cloud time
    """
    return self.handler.handle_time()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.disconnect">
    <p>def <span class="ident">disconnect</span>(</p><p>self, wait_for_replies=False, timeout=0)</p>
    </div>
    

    
  
    <div class="desc"><p>End Client connection to the Cloud</p>
<p>Parameters:
  wait_for_replies      (bool) When True, wait for any pending replies
                               to be received or time out before
                               disconnecting
  timeout             (number) Maximum time to wait before returning</p>
<p>Returns:
  STATUS_SUCCESS               Successfully disconnected</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.disconnect', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.disconnect" class="source">
    <pre><code>def disconnect(self, wait_for_replies=False, timeout=0):
    """
    End Client connection to the Cloud
    Parameters:
      wait_for_replies      (bool) When True, wait for any pending replies
                                   to be received or time out before
                                   disconnecting
      timeout             (number) Maximum time to wait before returning
    Returns:
      STATUS_SUCCESS               Successfully disconnected
    """
    return self.handler.disconnect(wait_for_replies=wait_for_replies,
                                   timeout=timeout)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.event_publish">
    <p>def <span class="ident">event_publish</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Publishes an event message to the Cloud</p>
<p>Parameters:
  message             (string) Message to publish</p>
<p>Returns:
  STATUS_SUCCESS               Event has been queued for publishing</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.event_publish', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.event_publish" class="source">
    <pre><code>def event_publish(self, message):
    """
    Publishes an event message to the Cloud
    Parameters:
      message             (string) Message to publish
    Returns:
      STATUS_SUCCESS               Event has been queued for publishing
    """
    ret = None
    if not self.offline:
        log = defs.PublishLog(message)
        ret = self.handler.queue_publish(log)
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.file_download">
    <p>def <span class="ident">file_download</span>(</p><p>self, file_name, download_dest, blocking=False, callback=None, timeout=0, file_global=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Download a file from the Cloud to the device (C2D)</p>
<p>Parameters:
  file_name           (string) File in Cloud to download
  download_dest       (string) Destination for downloaded file
  blocking              (bool) Wait for file transfer to complete
                               before returning. Otherwise return
                               immediately.
  callback              (func) Function to be executed as soon as file
                               transfer is complete. It will be passed
                               (client, file_name, status).
  timeout             (number) If blocking, maximum time to wait
                               before returning
  file_global                  Flag that indicates whether or not the
                               file to download is in the global file
                               store or the thing's file store</p>
<p>Returns:
  STATUS_FAILURE               Failed to download file.
  STATUS_NOT_FOUND             Could not find download directory to
                               download file to.
  STATUS_SUCCESS               File download successful
  STATUS_TIMED_OUT             Wait for file transfer timed out. File
                               transfer is still in progress.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.file_download', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.file_download" class="source">
    <pre><code>def file_download(self, file_name, download_dest, blocking=False,
                  callback=None, timeout=0, file_global=False):
    """
    Download a file from the Cloud to the device (C2D)
    Parameters:
      file_name           (string) File in Cloud to download
      download_dest       (string) Destination for downloaded file
      blocking              (bool) Wait for file transfer to complete
                                   before returning. Otherwise return
                                   immediately.
      callback              (func) Function to be executed as soon as file
                                   transfer is complete. It will be passed
                                   (client, file_name, status).
      timeout             (number) If blocking, maximum time to wait
                                   before returning
      file_global                  Flag that indicates whether or not the
                                   file to download is in the global file
                                   store or the thing's file store
    Returns:
      STATUS_FAILURE               Failed to download file.
      STATUS_NOT_FOUND             Could not find download directory to
                                   download file to.
      STATUS_SUCCESS               File download successful
      STATUS_TIMED_OUT             Wait for file transfer timed out. File
                                   transfer is still in progress.
    """
    return self.handler.request_download(file_name, download_dest, blocking,
                                         callback, timeout, file_global)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.file_upload">
    <p>def <span class="ident">file_upload</span>(</p><p>self, file_path, upload_name=None, blocking=False, callback=None, timeout=0, file_global=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Upload a file from the device to the Cloud (D2C)</p>
<p>Parameters:
  file_path           (string) Absolute path for file to upload.
  upload_name         (string) Name for file uploaded in Cloud.
                               Default is the file name on the device.
  blocking              (bool) Wait for file transfer to complete
                               before returning. Otherwise return
                               immediately.
  callback              (func) Function to be executed as soon as file
                               transfer is complete. It will be passed
                               (client, file_name, status).
  timeout             (number) If blocking, maximum time to wait
                               before returning
  file_global                  Flag that indicates whether or not the
                               file should be uploaded to the global
                               file store or the thing's file store</p>
<p>Returns:
  STATUS_FAILURE               Failed to upload file.
  STATUS_NOT_FOUND             Could not find find to upload in upload
                               directory.
  STATUS_SUCCESS               File upload successful
  STATUS_TIMED_OUT             Wait for file transfer timed out. File
                               transfer is still in progress.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.file_upload', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.file_upload" class="source">
    <pre><code>def file_upload(self, file_path, upload_name=None, blocking=False,
                callback=None, timeout=0, file_global=False):
    """
    Upload a file from the device to the Cloud (D2C)
    Parameters:
      file_path           (string) Absolute path for file to upload.
      upload_name         (string) Name for file uploaded in Cloud.
                                   Default is the file name on the device.
      blocking              (bool) Wait for file transfer to complete
                                   before returning. Otherwise return
                                   immediately.
      callback              (func) Function to be executed as soon as file
                                   transfer is complete. It will be passed
                                   (client, file_name, status).
      timeout             (number) If blocking, maximum time to wait
                                   before returning
      file_global                  Flag that indicates whether or not the
                                   file should be uploaded to the global
                                   file store or the thing's file store
    Returns:
      STATUS_FAILURE               Failed to upload file.
      STATUS_NOT_FOUND             Could not find find to upload in upload
                                   directory.
      STATUS_SUCCESS               File upload successful
      STATUS_TIMED_OUT             Wait for file transfer timed out. File
                                   transfer is still in progress.
    """
    ret = None
    if not self.offline:
        if os.path.isdir(file_path):
            result = []
            for fn in os.listdir(file_path):
                result.append(self.handler.request_upload((file_path+os.sep+fn), fn, blocking,
                                           callback, timeout, file_global))
            if not result:
                return STATUS_NOT_FOUND
            return max(result)
        ret = self.handler.request_upload(file_path, upload_name, blocking,
                                          callback, timeout, file_global)
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.initialize">
    <p>def <span class="ident">initialize</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Finish client setup by reading config files using any config values
already set, and initializing the client handler. This is required
before connection can be attempted.</p>
<p>Returns:
  STATUS_SUCCESS               Configuration completed successfully
  Exception                    Error in configuration</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.initialize', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.initialize" class="source">
    <pre><code>def initialize(self):
    """
    Finish client setup by reading config files using any config values
    already set, and initializing the client handler. This is required
    before connection can be attempted.
    Returns:
      STATUS_SUCCESS               Configuration completed successfully
      Exception                    Error in configuration
    """
    # Read JSON from config file. Does not overwrite any configuration set
    # in application.
    kwargs = {}
    config_path = os.path.join(self.config.config_dir, self.config.config_file)
    if os.path.exists(config_path):
        try:
            with open(config_path, "r") as config_file:
                kwargs.update(json.load(config_file))
        except IOError as error:
            print("Error parsing JSON from "
                    "{}".format(self.config.config_file))
            raise error
    else:
        print("Cannot find {}".format(self.config.config_file))
        raise IOError("Cannot find {}".format(self.config.config_file))
    self.config.update(kwargs, False)
    kwargs = {}
    # Check config directory for device_id. If it does not exist, generate a
    # uuid and write it to device_id.
    device_id_path = os.path.join(self.config.config_dir, "device_id")
    if os.path.exists(device_id_path):
        try:
            with open(device_id_path, "r") as id_file:
                self.config.device_id = id_file.read().strip()
        except:
            print("Failed to read device_id")
            raise IOError("Failed to read device_id")
    else:
        try:
            with open(device_id_path, "w") as id_file:
                self.config.device_id = self.identity.get_device_id()
                id_file.write(self.config.device_id)
        except:
            print("Failed to write device_id")
            raise IOError("Failed to write device_id")
    self.config.update(kwargs, False)
    # Check that all necessary configuration has been obtained
    if not self.config.cloud.token:
        print("Cloud token not set. Must be set in config")
        raise KeyError("Cloud token not set. Must be set in config")
    if not self.config.cloud.host:
        print("Cloud host addess not set. Must be set in config")
        raise KeyError("Cloud host address not set. Must be set in config")
    if not self.config.cloud.port:
        print("Cloud port not set. Must be set in config")
        raise KeyError("Cloud port not set. Must be set in config")
    # Generate key
    if self.config.app_id and self.config.device_id:
        self.config.key = "{}-{}".format(self.config.device_id,
                                         self.config.app_id)
    else:
        print("app_id or device_id not set. Required for key.")
        raise KeyError("app_id or device_id not set. Required for key.")
    if len(self.config.key) > 64:
        print("Key exceeds 64 bytes. Please specify an app_id under {} "
              "bytes in length".format(64-len(self.config.device_id)))
        raise KeyError("Key exceeds 64 bytes. Please specify an app_id "
                       "under {} bytes in length".format(
                           64-len(self.config.device_id)))
    # Final precedence config defaults
    config_defaults = {
        "keep_alive":DEFAULT_KEEP_ALIVE,
        "loop_time":DEFAULT_LOOP_TIME,
        "thread_count":DEFAULT_THREAD_COUNT,
        "ca_bundle_file":certifi.where()
    }
    self.config.update(config_defaults, False)
    # Initialize handler
    self.handler = Handler(self.config, self)
    # Access logger functions
    self.critical = self.handler.logger.critical
    self.debug = self.handler.logger.debug
    self.error = self.handler.logger.error
    self.info = self.handler.logger.info
    self.log = self.handler.logger.log
    self.warning = self.handler.logger.warning
    return STATUS_SUCCESS
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.is_alive">
    <p>def <span class="ident">is_alive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return whether or not the Client has exited</p>
<p>Returns:
  True                         Client is running
  False                        Client is not running</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.is_alive', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.is_alive" class="source">
    <pre><code>def is_alive(self):
    """
    Return whether or not the Client has exited
    Returns:
      True                         Client is running
      False                        Client is not running
    """
    return not self.handler.to_quit
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.is_connected">
    <p>def <span class="ident">is_connected</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the current connect status of the Client</p>
<p>Returns:
  True                         Connected to Cloud
  False                        Not connected to Cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.is_connected', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.is_connected" class="source">
    <pre><code>def is_connected(self):
    """
    Return the current connect status of the Client
    Returns:
      True                         Connected to Cloud
      False                        Not connected to Cloud
    """
    return self.handler.is_connected()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.location_publish">
    <p>def <span class="ident">location_publish</span>(</p><p>self, latitude, longitude, heading=None, altitude=None, speed=None, accuracy=None, fix_type=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Publish a location metric to the Cloud</p>
<p>Parameters:
  latitude            (number) Latitude coordinate
  longitude           (number) Longitude coordinate
  heading             (number) Heading
  altitude            (number) Altitude
  speed               (number) Speed
  accuracy            (number) Accuracy of fix
  fix_type            (string) Fix type</p>
<p>Returns:
  STATUS_SUCCESS               Location has been queued for publishing</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.location_publish', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.location_publish" class="source">
    <pre><code>def location_publish(self, latitude, longitude, heading=None, altitude=None,
                     speed=None, accuracy=None, fix_type=None):
    """
    Publish a location metric to the Cloud
    Parameters:
      latitude            (number) Latitude coordinate
      longitude           (number) Longitude coordinate
      heading             (number) Heading
      altitude            (number) Altitude
      speed               (number) Speed
      accuracy            (number) Accuracy of fix
      fix_type            (string) Fix type
    Returns:
      STATUS_SUCCESS               Location has been queued for publishing
    """
    location = defs.PublishLocation(latitude, longitude, heading=heading,
                                    altitude=altitude, speed=speed,
                                    accuracy=accuracy, fix_type=fix_type)
    return self.handler.queue_publish(location)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.log_level">
    <p>def <span class="ident">log_level</span>(</p><p>self, level)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the log level</p>
<p>Parameters:
  level             (string) Requested level</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.log_level', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.log_level" class="source">
    <pre><code>def log_level(self, level):
    """
    Set the log level
    
    Parameters:
      level             (string) Requested level
    """
    return self.handler.log_level(level)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.telemetry_publish">
    <p>def <span class="ident">telemetry_publish</span>(</p><p>self, telemetry_name, value, cloud_response=False, timestamp=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Publish telemetry to the Cloud</p>
<p>Parameters:
  telemetry_name      (string) Key of property to publish
  value               (number) Value to publish
  cloud_response      (bool) Wait for response from cloud
                             If true, the return status indicates if
                             it was sent to the cloud. Otherwise,
                             the return status is if it was queued.
  timestamp           (string) Optional datetime format timestamp to
                               override the timestamp applied by the API
Returns:
  STATUS_SUCCESS             Telemetry has been queued for publishing</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.telemetry_publish', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.telemetry_publish" class="source">
    <pre><code>def telemetry_publish(self, telemetry_name, value, cloud_response=False, timestamp=None):
    """
    Publish telemetry to the Cloud
    Parameters:
      telemetry_name      (string) Key of property to publish
      value               (number) Value to publish
      cloud_response      (bool) Wait for response from cloud
                                 If true, the return status indicates if
                                 it was sent to the cloud. Otherwise,
                                 the return status is if it was queued.
      timestamp           (string) Optional datetime format timestamp to
                                   override the timestamp applied by the API
    Returns:
      STATUS_SUCCESS             Telemetry has been queued for publishing
    """
    telem = defs.PublishTelemetry(telemetry_name, value, timestamp)
    return self.handler.request_publish(telem, cloud_response)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.telemetry_read_last_sample">
    <p>def <span class="ident">telemetry_read_last_sample</span>(</p><p>self, telemetry_name)</p>
    </div>
    

    
  
    <div class="desc"><p>Read back last/current telemetry sample from the Cloud</p>
<p>Parameters
  telemetry_name      (string) Key of property to publish</p>
<p>Returns:
  STATUS_SUCCESS               Telemetry has been queued for publishing
  value                        Value for last telemetry sample in cloud
  timestamp                    Timestamp for the sample</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.telemetry_read_last_sample', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.telemetry_read_last_sample" class="source">
    <pre><code>def telemetry_read_last_sample(self, telemetry_name):
    """
    Read back last/current telemetry sample from the Cloud
    Parameters
      telemetry_name      (string) Key of property to publish
    Returns:
      STATUS_SUCCESS               Telemetry has been queued for publishing
      value                        Value for last telemetry sample in cloud
      timestamp                    Timestamp for the sample
    """
    return self.handler.handle_telemetry_get(telemetry_name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="client.Client.update_thing_details">
    <p>def <span class="ident">update_thing_details</span>(</p><p>self, name=None, description=None, iccid=None, esn=None, imei=None, meid=None, imsi=None, unset_fields=[])</p>
    </div>
    

    
  
    <div class="desc"><p>Update a things description.  All fields are optional, if none
are specified, then the action is a noop.</p>
<p>Parameters:
    name              (string) Friendly name.
    description       (string) Description of thing.
    iccid             (string) ICCID
    esn               (string) ESN
    imei              (string) IMEI
    meid              (string) MEID
    imsi              (string) IMSI
    unset_fields      (list) List of field names above to unset.</p>
<p>Returns:
    STATUS_SUCCESS</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-client.Client.update_thing_details', this);">Show source &equiv;</a></p>
  <div id="source-client.Client.update_thing_details" class="source">
    <pre><code>def update_thing_details(self, name=None, description=None,
                         iccid=None, esn=None, imei=None, meid=None,
                         imsi=None, unset_fields=[]):
    """
    Update a things description.  All fields are optional, if none
    are specified, then the action is a noop.
    Parameters:
        name              (string) Friendly name.
        description       (string) Description of thing.
        iccid             (string) ICCID
        esn               (string) ESN
        imei              (string) IMEI
        meid              (string) MEID
        imsi              (string) IMSI
        unset_fields      (list) List of field names above to unset.
    Returns:
        STATUS_SUCCESS
    """
    return self.handler.handle_update_thing_details(name, description,
                                iccid, esn, imei, meid, imsi, unset_fields)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="client.Client.config" class="name">var <span class="ident">config</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="client.Client.error_handler" class="name">var <span class="ident">error_handler</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="client.Client.identity" class="name">var <span class="ident">identity</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="client.Client.idle_sleep" class="name">var <span class="ident">idle_sleep</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="client.Client.offline" class="name">var <span class="ident">offline</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
