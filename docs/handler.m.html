<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>handler API documentation</title>
    <meta name="description" content="Copyright (c) 2016-2017 Wind River Systems, Inc.

Licensed under the Apache License, Version 2.0 (th..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#handler.proxy_support">proxy_support</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#handler.is_valid_status">is_valid_status</a></li>
    <li class="mono"><a href="#handler.status_string">status_string</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#handler.Handler">Handler</a></span>
        
          
  <ul>
    <li class="mono"><a href="#handler.Handler.__init__">__init__</a></li>
    <li class="mono"><a href="#handler.Handler.action_acknowledge">action_acknowledge</a></li>
    <li class="mono"><a href="#handler.Handler.action_deregister">action_deregister</a></li>
    <li class="mono"><a href="#handler.Handler.action_progress_update">action_progress_update</a></li>
    <li class="mono"><a href="#handler.Handler.action_register_callback">action_register_callback</a></li>
    <li class="mono"><a href="#handler.Handler.action_register_command">action_register_command</a></li>
    <li class="mono"><a href="#handler.Handler.calc_file_checksum">calc_file_checksum</a></li>
    <li class="mono"><a href="#handler.Handler.connect">connect</a></li>
    <li class="mono"><a href="#handler.Handler.disconnect">disconnect</a></li>
    <li class="mono"><a href="#handler.Handler.do_file_get">do_file_get</a></li>
    <li class="mono"><a href="#handler.Handler.get_proxy_settings">get_proxy_settings</a></li>
    <li class="mono"><a href="#handler.Handler.handle_action">handle_action</a></li>
    <li class="mono"><a href="#handler.Handler.handle_attribute_get">handle_attribute_get</a></li>
    <li class="mono"><a href="#handler.Handler.handle_file_download">handle_file_download</a></li>
    <li class="mono"><a href="#handler.Handler.handle_file_upload">handle_file_upload</a></li>
    <li class="mono"><a href="#handler.Handler.handle_message">handle_message</a></li>
    <li class="mono"><a href="#handler.Handler.handle_ping">handle_ping</a></li>
    <li class="mono"><a href="#handler.Handler.handle_publish">handle_publish</a></li>
    <li class="mono"><a href="#handler.Handler.handle_telemetry_get">handle_telemetry_get</a></li>
    <li class="mono"><a href="#handler.Handler.handle_time">handle_time</a></li>
    <li class="mono"><a href="#handler.Handler.handle_update_thing_details">handle_update_thing_details</a></li>
    <li class="mono"><a href="#handler.Handler.handle_work_loop">handle_work_loop</a></li>
    <li class="mono"><a href="#handler.Handler.is_connected">is_connected</a></li>
    <li class="mono"><a href="#handler.Handler.log_level">log_level</a></li>
    <li class="mono"><a href="#handler.Handler.main_loop">main_loop</a></li>
    <li class="mono"><a href="#handler.Handler.num_unfinished">num_unfinished</a></li>
    <li class="mono"><a href="#handler.Handler.on_connect">on_connect</a></li>
    <li class="mono"><a href="#handler.Handler.on_disconnect">on_disconnect</a></li>
    <li class="mono"><a href="#handler.Handler.on_message">on_message</a></li>
    <li class="mono"><a href="#handler.Handler.on_publish">on_publish</a></li>
    <li class="mono"><a href="#handler.Handler.qos_level">qos_level</a></li>
    <li class="mono"><a href="#handler.Handler.queue_publish">queue_publish</a></li>
    <li class="mono"><a href="#handler.Handler.queue_work">queue_work</a></li>
    <li class="mono"><a href="#handler.Handler.request_download">request_download</a></li>
    <li class="mono"><a href="#handler.Handler.request_publish">request_publish</a></li>
    <li class="mono"><a href="#handler.Handler.request_upload">request_upload</a></li>
    <li class="mono"><a href="#handler.Handler.send">send</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#handler.socket">original_socket</a></span>
        
          
  <ul>
    <li class="mono"><a href="#handler.socket.__init__">__init__</a></li>
    <li class="mono"><a href="#handler.socket.accept">accept</a></li>
    <li class="mono"><a href="#handler.socket.close">close</a></li>
    <li class="mono"><a href="#handler.socket.detach">detach</a></li>
    <li class="mono"><a href="#handler.socket.dup">dup</a></li>
    <li class="mono"><a href="#handler.socket.get_inheritable">get_inheritable</a></li>
    <li class="mono"><a href="#handler.socket.makefile">makefile</a></li>
    <li class="mono"><a href="#handler.socket.sendfile">sendfile</a></li>
    <li class="mono"><a href="#handler.socket.set_inheritable">set_inheritable</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">handler</span> module</h1>
  <p>Copyright (c) 2016-2017 Wind River Systems, Inc.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at:
http://www.apache.org/licenses/LICENSE-2.0</p>
<p>Unless required by applicable law or agreed to in writing, software  distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler', this);">Show source &equiv;</a></p>
  <div id="source-handler" class="source">
    <pre><code>'''
    Copyright (c) 2016-2017 Wind River Systems, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at:
    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software  distributed
    under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
    OR CONDITIONS OF ANY KIND, either express or implied.
'''

"""
This module handles all the underlying functionality of the Client
"""

import json
import logging
import logging.handlers
import os
import random
import socket

# proxy support requires PySocks, it is an optional module
proxy_support = False
try:
    import socks
    proxy_support = True
except ImportError:
    pass
import ssl
import sys
import threading
from binascii import crc32
from datetime import datetime
from datetime import timedelta
from time import sleep
import requests

# for debugging only, uncomment the following two lines
#import httplib
#httplib.HTTPConnection.debuglevel = 1

import paho.mqtt.client as mqttlib

from device_cloud._core import constants
from device_cloud._core import defs
from device_cloud._core import tr50
from device_cloud._core.tr50 import TR50Command

original_socket = socket.socket

if sys.version_info.major == 2:
    import Queue as queue
else:
    import queue

def status_string(error_code):
    """
    Return a string describing the error code
    """

    return constants.STATUS_STRINGS[error_code]

def is_valid_status(error_code):
    """
    Check if passed object is a valid status code
    """

    return (error_code.__class__.__name__ == "int" and
            error_code >= constants.STATUS_SUCCESS and
            error_code <= constants.STATUS_FAILURE)


class Handler(object):
    """
    Handles all underlying functionality of the Client
    """

    def __init__(self, config, client):
        # Configuration
        self.config = config

        # Set Client
        self.client = client

        # Set up logging, with optional logging to a specified file
        if self.config.key:
            self.logger = logging.getLogger(self.config.key)
        else:
            self.logger = logging.getLogger("APP NAME HERE")
        log_formatter = logging.Formatter(constants.LOG_FORMAT,
                                          datefmt=constants.LOG_TIME_FORMAT)
        if not self.config.quiet:
            if self.config.use_syslog:
                print ("Logging to syslog...")
                log_handler = logging.handlers.SysLogHandler(address = '/dev/log')
            else:
                log_handler = logging.StreamHandler()
            log_handler.setFormatter(log_formatter)
            self.logger.addHandler(log_handler)

        if self.config.log_file:
            log_file_handler = logging.FileHandler(self.config.log_file)
            log_file_handler.setFormatter(log_formatter)
            self.logger.addHandler(log_file_handler)

        # Ensure we're not missing required configuration information
        if not self.config.key or not self.config.cloud.token:
            self.logger.error("Missing key or cloud token from configuration")
            raise KeyError("Missing key or cloud token from configuration")

        #log_level default set as DEBUG
        self.logger.setLevel(logging.DEBUG)
        self.qos_level(self.config.qos_level)

        # Print configuration
        self.logger.debug("CONFIG:\n%s", self.config)

        # Ensure the paho socket pair is not using proxy sockets
        # Save the original socket so that class members can use it,
        # e.g. remote login etc.
        socket.socket = original_socket
        self.original_socket = original_socket

        # Set up MQTT client
        if self.config.cloud.port == 443:
            self.mqtt = mqttlib.Client(self.config.key, transport="websockets")
        else:
            self.mqtt = mqttlib.Client(self.config.key)
        self.mqtt.on_connect = self.on_connect
        self.mqtt.on_disconnect = self.on_disconnect
        self.mqtt.on_message = self.on_message
        self.mqtt.on_publish = self.on_publish
        self.mqtt.username_pw_set(self.config.key, self.config.cloud.token)

        # Set up proxy.  Note: PySocks is required for this, but it is
        # an optional pkg.  Check for it.
        if (proxy_support == True):
            if ("host" in self.config.proxy):
                proxy_type = None
                if self.config.proxy.type.upper() == "SOCKS4":
                    proxy_type = socks.SOCKS4
                elif self.config.proxy.type.upper() == "SOCKS5":
                    proxy_type = socks.SOCKS5
                elif self.config.proxy.type.upper() == "HTTP":
                    proxy_type = socks.HTTP
                else:
                    self.logger.error("Invalid proxy type. Supported types are "
                              "SOCKS4/SOCKS5/HTTP.")
                    raise KeyError("Invalid proxy type. Supported types are "
                           "SOCKS4/SOCKS5/HTTP.")
                username = None
                if "username" in self.config.proxy:
                    username = self.config.proxy.username
                password = None
                if "password" in self.config.proxy:
                    password = self.config.proxy.password
                socks.set_default_proxy(proxy_type, self.config.proxy.host,
                            self.config.proxy.port, True, username,
                            password)
                socket.socket = socks.socksocket
        elif ("host" in self.config.proxy and proxy_support == False):
            self.logger.error("PySocks module required for proxy support "
                     "Install PySocks.")
            raise KeyError("PySocks module required for proxy support "
                    "Install PySocks.")

        # Dict to associate action names with callback functions and any user
        # data
        self.callbacks = defs.Callbacks()

        # Connection state of the Client
        self.state = constants.STATE_DISCONNECTED

        # Track last time the app was connected so keep alive can time out
        self.last_connected = datetime.utcnow()

        # Lock for thread safety
        self.lock = threading.Lock()

        # Queue for any pending publishes (number, string, location, etc.)
        self.publish_queue = queue.Queue()

        # Dicts to track which messages sent out have not received replies. Also
        # stores any actions to be taken when the reply is received.
        self.reply_tracker = defs.OutTracker()
        self.no_reply = []

        # Counter to allow every message to be sent on a unique topic
        self.topic_counter = 1

        # Flag for notifying client to exit
        self.to_quit = True

        # Telemetry Response Flag
        self.pub_wait = self.pub_response = False
        self.pub_topic = '0000'

        # Thread trackers. Main thread for handling MQTT loop, and worker
        # threads for everything else.
        self.main_thread = None
        self.worker_threads = []

        # Queue to track any pending work (parsing messages, actions,
        # publishing, file transfer, etc.)
        self.work_queue = queue.Queue()

        # store any requested data here
        self.response = {}

    def action_deregister(self, action_name):
        """
        Disassociate any function or command from an action in the Cloud
        """

        status = constants.STATUS_SUCCESS

        try:
            self.callbacks.remove_action(action_name)
        except KeyError as error:
            self.logger.error(str(error))
            status = constants.STATUS_NOT_FOUND

        return status

    def action_acknowledge(self, request_id, error_code, error_message):
        """
        Send acknowledgement for action (method) request by the cloud
        """

        cmd = tr50.create_mailbox_ack(request_id, error_code, error_message)
        message = defs.OutMessage(cmd, "Action Acknowledge "
                                       "{} {}: \"{}\"".format(request_id,
                                                              error_code,
                                                              error_message))
        return self.send(message)

    def action_progress_update(self, request_id, message):
        """
        Update message for action (method) request in Cloud
        """

        cmd = tr50.create_mailbox_update(request_id, message)
        message = defs.OutMessage(cmd, "Update Action Progress "
                                  "{} \"{}\"".format(request_id, message))
        return self.send(message)

    def action_register_callback(self, action_name, callback_function,
                                 user_data=None):
        """
        Associate a callback function with an action in the Cloud
        """
        status = constants.STATUS_SUCCESS
        action = defs.Action(action_name, callback_function, self.client,
                             user_data=user_data)
        try:
            self.callbacks.add_action(action)
            self.logger.info("Registered action \"%s\" with function \"%s\"",
                             action_name, callback_function.__name__)
        except KeyError as error:
            self.logger.error("Failed to register action. %s", str(error))
            status = constants.STATUS_EXISTS

        return status

    def action_register_command(self, action_name, command):
        """
        Associate a console command with an action in the Cloud
        """

        status = constants.STATUS_SUCCESS
        action = defs.ActionCommand(action_name, command, self.client)
        try:
            self.callbacks.add_action(action)
            self.logger.info("Registered action \"%s\" with command \"%s\"",
                             action_name, command)
        except KeyError as error:
            self.logger.error("Failed to register action. %s", str(error))
            status = constants.STATUS_EXISTS

        return status

    def connect(self, timeout=0):
        """
        Connect to MQTT and start main thread
        """

        self.to_quit = False
        status = constants.STATUS_FAILURE
        result = -1

        # Ensure we have a host and port to connect to
        if not self.config.cloud.host or not self.config.cloud.port:
            self.logger.error("Missing host or port from configuration")
            status = constants.STATUS_BAD_PARAMETER

        else:
            current_time = datetime.utcnow()
            end_time = current_time + timedelta(seconds=timeout)
            self.state = constants.STATE_CONNECTING

            # Add network check and poll here while it is not
            # available.  Otherwise, the service will exit which is
            # not ideal if you do not have a service monitor like
            # systemd.
            test_network = True
            self.logger.info("Checking for network connectivity...")
            while test_network:
                try:
                    ret = socket.gethostbyname(self.config.cloud.host)
                    if ret:
                        self.logger.info("Network is active" )
                        test_network = False
                except socket.error as err:
                    self.logger.error("Network error detected: %s" % str(err))
                    sleep(1)

            # Start a secure connection if using a secure port and the cert file
            # is available
            if self.config.cloud.port in constants.SECURE_PORTS:
                if self.config.validate_cloud_cert is False:
                    context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
                    context.verify_mode = ssl.CERT_NONE
                    context.check_hostname = False
                    self.mqtt.tls_set_context(context)
                elif not self.config.ca_bundle_file:
                    self.logger.error("Missing certificate bundle from configuration")
                    status = constants.STATUS_BAD_PARAMETER
                elif not os.path.isfile(self.config.ca_bundle_file):
                    self.logger.error("Certificate bundle not found")
                    status = constants.STATUS_NOT_FOUND
                else:
                    context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
                    context.load_verify_locations(cafile=self.config.ca_bundle_file)
                    context.verify_mode = ssl.CERT_REQUIRED
                    context.check_hostname = True
                    self.mqtt.tls_set_context(context)

            # status != bad_parameter or not_found
            if status == constants.STATUS_FAILURE:
                # Start MQTT connection
                try:
                    result = self.mqtt.connect(self.config.cloud.host,
                                               self.config.cloud.port, 60)
                except Exception as error:
                    # socket.gaierror or ssl.SSLError
                    self.state = constants.STATE_DISCONNECTED
                    self.logger.error(str(error))

        if result == 0:
            # Successful MQTT connection
            self.logger.info("Connecting...")

            # Start main loop thread so that MQTT can make the on_connect
            # callback
            self.main_thread = threading.Thread(target=self.main_loop)
            self.main_thread.start()

            # Wait for cloud connection
            while ((timeout == 0 or current_time < end_time) and
                   self.state == constants.STATE_CONNECTING):
                sleep(0.1)
                current_time = datetime.utcnow()

            # Still connecting, timed out
            if self.state == constants.STATE_CONNECTING:
                self.logger.error("Connection timed out")
                status = constants.STATUS_TIMED_OUT

        if self.state == constants.STATE_CONNECTED:
            # Connected Successfully
            status = constants.STATUS_SUCCESS

            # Start worker threads if we have successfully connected
            for _ in range(self.config.thread_count):
                self.worker_threads.append(threading.Thread(
                    target=self.handle_work_loop))
            for thread in self.worker_threads:
                thread.start()

        else:
            # Not connected. Stop main loop.
            self.logger.error("Failed to connect")
            self.to_quit = True
            self.state = constants.STATE_DISCONNECTED
            if self.main_thread:
                self.main_thread.join()
                self.main_thread = None

        # Return result of connection
        return status

    def disconnect(self, wait_for_replies=False, timeout=0):
        """
        Stop threads and shut down MQTT client
        """

        current_time = datetime.utcnow()
        end_time = current_time + timedelta(seconds=timeout)

        # Publish any data that was queued before disconnecting
        if not self.publish_queue.empty():
            self.queue_work(defs.Work(constants.WORK_PUBLISH, None))

        # Wait for pending work that has not been dealt with
        self.logger.info("Disconnecting...")
        while ((timeout == 0 or current_time < end_time) and
               not self.work_queue.empty()):
            sleep(0.1)
            current_time = datetime.utcnow()

        # Optionally wait for any outstanding replies.
        if wait_for_replies and self.is_connected():
            self.logger.info("Waiting for replies...")
            while ((timeout == 0 or current_time < end_time) and
                   len(self.reply_tracker) != 0):
                sleep(0.1)
                current_time = datetime.utcnow()

        self.to_quit = True
        #TODO: Kill any hanging threads
        if threading.current_thread() not in self.worker_threads:
            if self.main_thread:
                self.main_thread.join()
                self.main_thread = None

        return constants.STATUS_SUCCESS

    def handle_action(self, action_request):
        """
        Handle action execution requests from Cloud
        """

        result_code = -1
        result_args = {"mail_id":action_request.request_id}
        action_result = None
        action_failed = False

        try:
            # Execute callback
            action_result = self.callbacks.execute_action(action_request)

        except Exception as error:
            # Error with action execution. Might not have been registered.
            action_failed = True
            self.logger.error("Action %s execution failed", action_request.name)
            self.logger.error(".... %s", str(error))
            result_code = constants.STATUS_FAILURE
            result_args["error_message"] = "ERROR: {}".format(str(error))
            if action_request.name not in self.callbacks:
                result_code = constants.STATUS_NOT_FOUND
            else:
                self.logger.exception("Exception:")

        # Action execution did not raise an error
        if not action_failed:
            # Handle returning a tuple or just a status code
            if action_result.__class__.__name__ == "tuple":
                result_code = action_result[0]
                if len(action_result) >= 2:
                    result_args["error_message"] = str(action_result[1])
                if len(action_result) >= 3:
                    result_args["params"] = action_result[2]
            else:
                result_code = action_result

            if not is_valid_status(result_code):
                # Returned 'status' is not a valid status
                error_string = ("Invalid return status: " +
                                str(result_code))
                self.logger.error(error_string)
                result_code = constants.STATUS_BAD_PARAMETER
                result_args["error_message"] = "ERROR: " + error_string

        # Return status to Cloud
        # Check for invoked status.  If so, return mail box update not
        # ack.  Ack is the final notification.  This breaks triggers
        # etc because it doesn't update the status.
        result_args["error_code"] = tr50.translate_error_code(result_code)
        if result_code == constants.STATUS_INVOKED:
                update_args = {"mail_id":action_request.request_id}
                update_args["message"] = "Invoked"
                mailbox_ack = tr50.create_mailbox_update(**update_args)
        else:
                mailbox_ack = tr50.create_mailbox_ack(**result_args)

        message_desc = "Action Complete \"{}\"".format(action_request.name)
        message_desc += " result : {}({})".format(result_code,
                                                  status_string(result_code))
        if result_args.get("error_message"):
            message_desc += " \"{}\"".format(result_args["error_message"])
        if result_args.get("params"):
            message_desc += " \"{}\"".format(str(result_args["params"]))
        message = defs.OutMessage(mailbox_ack, message_desc)
        status = self.send(message)
        return status

    def handle_attribute_get(self, attribute_name ):
        command = tr50.create_attribute_current(self.config.key, attribute_name)
        message_desc = "Reading current attribute..."
        message = defs.OutMessage(command, message_desc)

        self.pub_wait = True
        status = self.send(message)
        value = None
        timestamp = None

        # Wait for response from sending to cloud
        while self.pub_wait:
            sleep(0.5)
        # Convert to return codes
        if self.pub_response:
            ret = constants.STATUS_SUCCESS
        else:
            ret = constants.STATUS_FAILURE

        # make sure the key exists or there will be a KeyError
        # exception
        if 'attribute_current_value' in self.response.keys():
            value = self.response['attribute_current_value']

        if 'attribute_current_timestamp' in self.response.keys():
            timestamp = self.response['attribute_current_timestamp']
        return ret, value, timestamp

    def calc_file_checksum(self, file_name):
        """
        Calculate the crc32 checksum on a file and return the string
        interpretation of it.  Checksum of None means it failed.
        """
        sample = 0
        checksum = None
        if os.path.exists(file_name):
            for chunk in open(file_name, "rb"):
                sample = crc32(chunk, sample)
            checksum = "%s" % (sample & 0xffffffff)
        return checksum

    def do_file_get(self, url, validate, file_xfer_obj):
        """
        Perform a get on the specified file.  Handle all errors and
        exceptions and resumuption from where the download left off.
        """
        response = None

        # -------------------------------------------------------
        # Resume download:
        # -the .part file should exist, but if it doesn't force a
        # clean download
        # -for resume, set the Range header for resume
        # -set the file args to append or overwrite mode
        # -------------------------------------------------------
        if file_xfer_obj.resume_download and os.path.exists(file_xfer_obj.download_temp_path):
            resume_from = os.path.getsize(file_xfer_obj.download_temp_path)
            hdrs = {'Range':'bytes=%s-' % resume_from}
            self.logger.info("Resuming download of %s from %d bytes",
                file_xfer_obj.download_temp_path, resume_from )
            file_args = "ab"
        else:
            hdrs = {}
            file_args = "wb"

        # ---------------------------------------------------------
        # Downloading:
        # -start the download, validate and check use a connectivity
        # timeout so that we can quickly be notified and retry
        # -iterate and write chunks to file
        # -print out progress % but throttle it so that it doesn't
        # overwhelm the system, e.g. progress % 100 == 0
        # -crc32 must be added intrementally and compared later
        # -handle connection and http exceptions
        # -make sure not to retry on http errors > 400
        # -throttle printouts
        # ---------------------------------------------------------
        proxies = self.get_proxy_settings()
        response = requests.get(url, stream=True, verify=validate, timeout=3,
             headers=hdrs, proxies=proxies)
        self.logger.debug("HTTP Status %s" % response.status_code)
        if response.status_code == 200 or response.status_code == 206:
            count = 0
            download_len = 0
            chunk_size = 4096
            with open(file_xfer_obj.download_temp_path, file_args) as temp_file:
                try:
                    for chunk in response.iter_content(chunk_size):
                        if not chunk:
                            break
                        temp_file.write(chunk)
                        if count % 100 == 0:
                            download_len = int(os.path.getsize(file_xfer_obj.download_temp_path))
                            progress = 100 * (float(download_len)/file_xfer_obj.file_size)
                            self.logger.debug("Download progress %0.2f(%%)",
                                 float(progress))
                        count +=1
                except (Exception) as e:
                    self.logger.error("Exception: %s",str(e))
            response.close()
            temp_file.close()

            # -------------------------------------------------------------
            # Validation phase:
            # -if checksums match, move/rename temporary file to real file name
            # Windows requires the target file to be removed if it
            # exists
            # -if the file size is not correct, retry
            # -if the checksum is not correct, fatal, meaning we
            # downloaded everything correctly but the file content is not
            # correct.  No way to recover, just return failure.
            # -------------------------------------------------------------
            checksum = self.calc_file_checksum(file_xfer_obj.download_temp_path)
            self.logger.debug("Checksum calculated=%s, checksum expected %s",
                checksum, file_xfer_obj.file_checksum)
            if (file_xfer_obj.file_checksum == None) or (checksum == str(file_xfer_obj.file_checksum)):
                self.logger.info("Checksum is correct")
                try:
                    os.rename(file_xfer_obj.download_temp_path, file_xfer_obj.file_path)
                except:
                    os.remove(file_xfer_obj.file_path)
                    os.rename(file_xfer_obj.download_temp_path, file_xfer_obj.file_path)
                self.logger.info("Successfully downloaded %s", file_xfer_obj.file_name)
                status = constants.STATUS_SUCCESS
            elif download_len != file_xfer_obj.file_size:
                self.logger.error("Download was interrupted, trying again")
                status = constants.STATUS_TRY_AGAIN
            else:
                self.logger.error("Fatal error: download completed but checksum"
                   " does not match expected.  Deleting file.")
                os.remove(file_xfer_obj.download_temp_path)
                status = constants.STATUS_FAILURE

        elif response.status_code >= 400:
            self.logger.error("A fatal HTTP error occurred: %s", response.reason)
            status = constants.STATUS_FAILURE
        else:
            self.logger.error("File transfer interrupted.  Trying again.")
            status = constants.STATUS_TRY_AGAIN
        return status

    def handle_file_download(self, file_xfer_obj):
        """
        Handle any accepted C2D file transfers
        """
        # -----------------------------------------------------------
        # File download handler:
        # -prepare for a file download, create temp file, make sure
        # all directories exist.
        # -call do_file_get in a loop unless we get a STATUS_FAILURE,
        # which means it is fatal.
        # -----------------------------------------------------------
        status = constants.STATUS_SUCCESS
        self.logger.info("Downloading \"%s\"", file_xfer_obj.file_name)
        self.logger.info("File size \"%d\"", file_xfer_obj.file_size)
        url = "https://{}/file/{}".format(self.config.cloud.host, file_xfer_obj.file_id)
        download_dir = os.path.dirname(file_xfer_obj.file_path)
        temp_file_name = "".join([random.choice("0123456789") for _ in range(10)])
        temp_file_name += ".part"
        temp_path = os.path.join(download_dir, temp_file_name)
        file_xfer_obj.download_temp_path = temp_path

        if not os.path.exists(download_dir):
            try:
                os.makedirs(download_dir)
            except OSError as err:
                self.logger.exception(err)
                status = constants.STATUS_BAD_PARAMETER
        elif not os.path.isdir(download_dir):
            self.logger.error("Failed to download %s (destination error)",
                              file_xfer_obj.file_name)
            status = constants.STATUS_IO_ERROR

        if status == constants.STATUS_SUCCESS:
            if (self.config.validate_cloud_cert is False or
                    not self.config.ca_bundle_file or
                    not os.path.isfile(self.config.ca_bundle_file)):
                validate = False
            else:
                validate = self.config.validate_cloud_cert

            # ----------
            # Retry loop
            # ----------
            status = self.do_file_get(url, validate, file_xfer_obj)
            while (status == constants.STATUS_TRY_AGAIN ):
                file_xfer_obj.resume_download = True
                status = self.do_file_get(url, validate, file_xfer_obj)
                sleep(1)

        file_xfer_obj.status = status
        file_xfer_obj.finish()
        return status

    def get_proxy_settings(self):
        if self.config.proxy:
            self.logger.debug("Proxy support detected")
            self.logger.debug("\ttype {} host {} port {}"
                .format(self.config.proxy.type,
                self.config.proxy.host,
                str(self.config.proxy.port )))

            proxy_host = self.config.proxy.host + ':' + str(self.config.proxy.port)
            proxy_type = self.config.proxy.type.lower()

            proxy_auth = ""

            # setup auth
            if self.config.proxy.username:
                proxy_auth = self.config.proxy.username
            if self.config.proxy.password:
                proxy_auth += ':' + self.config.proxy.password
                proxy_auth += '@'

            # key type is always http.  There is a bug when using
            # https.  The proxy tries to do a connect and fails with a
            # 403 error.
            proxies = {
                'http':  proxy_type + '://' + proxy_auth + proxy_host
            }
        else:
            proxies = None

        return proxies

    def handle_file_upload(self, upload):
        """
        Handle any accepted D2C file transfers
        """

        #TODO: Timeout

        status = constants.STATUS_SUCCESS

        self.logger.info("Uploading \"%s\" as \"%s\"",
                         os.path.basename(upload.file_path), upload.file_name)

        # Start creating URL for file upload
        url = "https://{}/file/{}".format(self.config.cloud.host,
                                          upload.file_id)

        response = None
        proxies = self.get_proxy_settings()

        if os.path.exists(upload.file_path):
            # If file exists attempt upload
            with open(upload.file_path, "rb") as up_file:
                # Secure or insecure HTTPS Post
                if (self.config.validate_cloud_cert is False or
                        not self.config.ca_bundle_file):
                    response = requests.post(url, data=up_file,
                    verify=False, proxies=proxies)
                else:
                    cert_location = self.config.ca_bundle_file
                    response = requests.post(url, data=up_file,
                                             verify=cert_location,
                                             proxies=proxies)

            if response.status_code == 200:
                self.logger.info("Successfully uploaded \"%s\"",
                                 upload.file_name)
                status = constants.STATUS_SUCCESS
            else:
                self.logger.error("Failed to upload \"%s\"",
                                  upload.file_name)
                self.logger.debug(".... %s", response.content)
                status = constants.STATUS_FAILURE

        else:
            # File does not exist
            self.logger.error("Cannot find file \"%s\". Upload failed.",
                              upload.file_path)
            status = constants.STATUS_NOT_FOUND

        # Update file transfer status
        upload.status = status

        # Call callback if it exists
        upload.finish()

        return status

    def handle_message(self, mqtt_message):
        """
        Handle messages received from Cloud
        """

        status = constants.STATUS_NOT_SUPPORTED

        msg_json = mqtt_message.json
        if "notify/" in mqtt_message.topic:
            # Received a notification
            if mqtt_message.topic[len("notify/"):] == "mailbox_activity":
                # Mailbox activity, send a request to check the mailbox
                self.logger.info("Recevied notification of mailbox activity")
                mailbox_check = tr50.create_mailbox_check(auto_complete=False)
                to_send = defs.OutMessage(mailbox_check, "Mailbox Check")
                self.send(to_send)
                status = constants.STATUS_SUCCESS

        elif "reply/" in mqtt_message.topic:
            # Received a reply to a previous message
            topic_num = mqtt_message.topic[len("reply/"):]
            for command_num in msg_json:
                reply = msg_json[command_num]

                # Retrieve the sent message that this is a reply for, removing
                # it from being tracked
                self.lock.acquire()
                try:
                    sent_message = self.reply_tracker.pop_message(topic_num,
                                                                  command_num)
                except KeyError as error:
                    self.logger.error(error.message)
                    continue
                finally:
                    self.lock.release()
                sent_command_type = sent_message.command.get("command")

                # Log success status of reply
                if reply.get("success"):
                    self.logger.info("Received success for %s-%s - %s",
                                     topic_num, command_num, sent_message)
                else:
                    self.logger.error("Received failure for %s-%s - %s",
                                      topic_num, command_num, sent_message)
                    self.logger.error(".... %s", str(reply))

                    if self.client.error_handler:
                        self.client.error_handler(
                        reply.get("errorCodes", []),
                        sent_message,
                        str(reply))

                # Return "success" status
                if self.pub_wait:
                    if self.pub_topic == topic_num:
                        self.pub_response = reply.get("success")
                        self.pub_wait = False
                    else:
                        self.pub_wait = self.pub_response = False

                # Check what kind of message this is a reply to
                if sent_command_type == TR50Command.file_get:
                    # Recevied a reply for a file download request
                    if reply.get("success"):
                        file_id = reply["params"].get("fileId")
                        file_checksum = reply["params"].get("crc32")
                        file_size = reply["params"].get("fileSize")
                        file_transfer = sent_message.data
                        file_transfer.file_id = file_id
                        file_transfer.file_checksum = file_checksum
                        file_transfer.file_size = file_size
                        work = defs.Work(constants.WORK_DOWNLOAD, file_transfer)
                        self.queue_work(work)
                    else:
                        if -90008 in reply.get("errorCodes", []):
                            sent_message.data.status = constants.STATUS_NOT_FOUND
                        elif sent_message.data != None:
                            sent_message.data.status = constants.STATUS_FAILURE

                elif sent_command_type == TR50Command.file_put:
                    # Received a reply for a file upload request
                    if reply.get("success"):
                        file_id = reply["params"].get("fileId")
                        file_transfer = sent_message.data
                        file_transfer.file_id = file_id
                        work = defs.Work(constants.WORK_UPLOAD, file_transfer)
                        self.queue_work(work)
                    else:
                        sent_message.data.status = constants.STATUS_FAILURE

                elif sent_command_type == TR50Command.mailbox_check:
                    # Received a reply for a mailbox check
                    if reply.get("success"):
                        try:
                            for mail in reply["params"]["messages"]:
                                mail_command = mail.get("command")
                                if mail_command == "method.exec":
                                    # Action execute request in mailbox
                                    mail_id = mail.get("id")
                                    action_name = mail["params"].get("method")
                                    action_params = mail["params"].get("params")
                                    action_request = defs.ActionRequest(mail_id,
                                                                        action_name,
                                                                        action_params)
                                    work = defs.Work(constants.WORK_ACTION,
                                                     action_request)
                                    self.queue_work(work)
                        except:
                            pass
                elif sent_command_type == TR50Command.diag_time:
                    # Recevied a reply for a ping request
                    if reply.get("success"):
                        mill = reply["params"].get("time")
                        print (datetime.fromtimestamp(mill/1000.0))

                    else:
                        if -90008 in reply.get("errorCodes", []):
                            sent_message.data.status = constants.STATUS_NOT_FOUND
                        else:
                            sent_message.data.status = constants.STATUS_FAILURE

                elif sent_command_type == TR50Command.diag_ping:
                    # Recevied a reply for a ping request
                    if reply.get("success"):
                       print ('*Connection Okay* \n')
                    else:
                        if -90008 in reply.get("errorCodes", []):
                            sent_message.data.status = constants.STATUS_NOT_FOUND
                        else:
                            sent_message.data.status = constants.STATUS_FAILURE

                elif sent_command_type == TR50Command.property_current:
                    # Recevied a reply for a ping request
                    if reply.get("success"):
                       params = reply.get("params")
                       self.response['telemetry_current_value'] = params.get("value")
                       self.response['telemetry_current_timestamp'] = params.get("ts")
                    else:
                        if -90008 in reply.get("errorCodes", []):
                            sent_message.data.status = constants.STATUS_NOT_FOUND
                        elif sent_message.data != None:
                            sent_message.data.status = constants.STATUS_FAILURE
                elif sent_command_type == TR50Command.attribute_current:
                    # Recevied a reply for a ping request
                    if reply.get("success"):
                       params = reply.get("params")
                       self.response['attribute_current_value']  = params.get("value")
                       self.response['attribute_current_timestamp']  = params.get("ts")
                    else:
                        if -90008 in reply.get("errorCodes", []):
                            sent_message.data.status = constants.STATUS_NOT_FOUND
                        elif  sent_message.data != None:
                            sent_message.data.status = constants.STATUS_FAILURE
            status = constants.STATUS_SUCCESS

        return status

    def handle_publish(self):
        """
        Publish any pending publishes in the publish queue, or the cloud logger
        """

        status = constants.STATUS_SUCCESS

        # Collect all pending publishes in publish queue
        to_publish = []
        while not self.publish_queue.empty():
            try:
                to_publish.append(self.publish_queue.get())
            except queue.Empty:
                break

        if to_publish:
            # If pending publishes are found, parse into list for sending
            messages = []
            batch = {}
            batch['PublishAlarm'] = []
            batch['PublishAttribute'] = []
            batch['PublishTelemetry'] = []
            batch['PublishLocation'] = []
            batch['PublishLog'] = []
            for pub in to_publish:
                message = None
                # ------------------
                # Alarms
                # ------------------
                if pub.type == "PublishAlarm":
                    batch[pub.type].append(
                        tr50.create_alarm_batch_item(
                            pub.name,
                            pub.state,
                            pub.timestamp,
                            pub.message,
                            pub.republish))

                # ------------------
                # Attributes
                # ------------------
                elif pub.type == "PublishAttribute":
                    batch[pub.type].append(
                        tr50.create_attribute_batch_item(
                            pub.name,
                            pub.value,
                            pub.timestamp))

                elif pub.type == "PublishTelemetry":
                    batch[pub.type].append(
                        tr50.create_property_batch_item(
                            pub.name,
                            pub.value,
                            pub.timestamp ))

                # ------------------
                # Location
                # ------------------
                elif pub.type == "PublishLocation":
                    batch[pub.type].append(
                        tr50.create_location_batch_item(
                            pub.latitude,
                            pub.longitude,
                            pub.heading,
                            pub.altitude,
                            pub.speed,
                            pub.accuracy,
                            pub.fix_type,
                            pub.timestamp))

                # ------------------
                # Event logs
                # ------------------
                elif pub.type == "PublishLog":
                    command = tr50.create_log_publish(self.config.key,
                                                      pub.message,
                                                      timestamp=pub.timestamp)
                    message_desc = "Log Publish {}".format(pub.message)
                    message = defs.OutMessage(command, message_desc)

                if message:
                    messages.append(message)

            # Send all publishes
            if messages:
                status = self.send(messages)

            # send out batches
            if batch['PublishAlarm']:
                timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
                command = tr50.create_alarm_publish(self.config.key,
                                                    "alarm_batch",
                                                    "Alarm Batch",
                                                    timestamp=timestamp,
                                                    republish=False,
                                                    batch=True)
                message_desc = "Alarm Publish {}".format("alarm_batch")
                message_desc += " : \"{}\"".format("Alarm Batch")
                batch_msg = defs.OutMessage(command, message_desc)
                batch_msg.command['params']['state'] = 0
                batch_msg.command['params']['data'] = batch['PublishAlarm']
                status = self.send(batch_msg)

            if batch['PublishAttribute']:
                timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
                command = tr50.create_attribute_publish(self.config.key,
                                                        "attribute_batch",
                                                        "Attribute Batch",
                                                        timestamp=timestamp,
                                                        batch=True)
                message_desc = "Attribute Publish {}".format("attribute_batch")
                message_desc += " : \"{}\"".format("Attribute Batch")
                batch_msg = defs.OutMessage(command, message_desc)
                batch_msg.command['params']['data'] = batch['PublishAttribute']
                status = self.send(batch_msg)

            if batch['PublishLocation']:
                timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
                command = tr50.create_location_publish(self.config.key,
                                                        "location_batch",
                                                        "Location Batch",
                                                        timestamp=timestamp,
                                                        batch=True)
                message_desc = "Location Publish {}".format("location_batch")
                message_desc += " : \"{}\"".format("Location Batch")
                batch_msg = defs.OutMessage(command, message_desc)
                batch_msg.command['params']['data'] = batch['PublishLocation']
                status = self.send(batch_msg)

            if batch['PublishTelemetry']:
                timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
                command = tr50.create_property_publish(self.config.key,
                                                        "property_batch",
                                                        "Property Batch",
                                                        timestamp=timestamp,
                                                        batch=True)
                message_desc = "Property Publish {}".format("property_batch")
                message_desc += " : \"{}\"".format("Property Batch")
                batch_msgs = defs.OutMessage(command, message_desc)
                batch_msgs.command['params']['data'] =  batch['PublishTelemetry']
                status = self.send(batch_msgs)

        return status

    def handle_work_loop(self):
        """
        Loop for worker threads to handle any items put on the work queue
        """

        # Continuously loop while connected
        while not self.to_quit:
            work = None
            try:
                work = self.work_queue.get(timeout=self.config.loop_time)
            except queue.Empty:
                pass
            # If work is retrieved from the queue, handle it based on type
            if work:
                try:
                    if work.type == constants.WORK_MESSAGE:
                        self.handle_message(work.data)
                    elif work.type == constants.WORK_PUBLISH:
                        self.handle_publish()
                    elif work.type == constants.WORK_ACTION:
                        self.handle_action(work.data)
                    elif work.type == constants.WORK_DOWNLOAD:
                        self.handle_file_download(work.data)
                    elif work.type == constants.WORK_UPLOAD:
                        self.handle_file_upload(work.data)
                except Exception:
                    # Print traceback, but don't kill thread
                    self.logger.exception("Exception:")

        return constants.STATUS_SUCCESS

    def handle_ping(self):
        """
        Request connection check
        """
        command = tr50.create_diag_ping()
        message_desc = "Connected"
        message = defs.OutMessage(command, message_desc)
        status = self.send(message)
        return constants.STATUS_SUCCESS

    def handle_update_thing_details(self, name=None, description=None,
                            iccid=None, esn=None, imei=None, meid=None,
                            imsi=None, unset_fields=[]):
        """
        Request to update a things definition.  The thing key must be
        immutable.  Friendly name and other non connectivity tracking
        keys can be changed, e.g. name, description, ICCID, ESN, IMEI,
        IMSI.
        """
        # if any of the default values are None, unset them in the
        # thing update. Support unsetting members in the thing
        # description.  Maybe remove the unsupported tunnel
        # fields from the thing description TBD.
        unset = []
        list_test = True
        if isinstance(unset_fields, list):
            print("unset_fields is a list of %d items" % len(unset_fields))
            if len(unset_fields) > 0:
                for v in unset_fields:
                    unset.append(v)
        else:
            list_test = False
            status = constants.STATUS_PARSE_ERROR

        if list_test:
            command = tr50.create_thing_update(self.config.key, name,
                            description, iccid, esn, imei, meid, imsi,
                            unset)
            message_desc = "Update Thing Details"
            message = defs.OutMessage(command, message_desc)
            status = self.send(message)
        return status

    def handle_time(self):
        """
        Request time from the cloud
        """
        command = tr50.create_diag_time()
        message_desc = "Retrieving Time.."
        message = defs.OutMessage(command, message_desc)
        status = self.send(message)
        return constants.STATUS_SUCCESS

    def handle_telemetry_get(self, telem_name ):
        """
        Add data to publish queue and wait for cloud response
        """
        command = tr50.create_property_get_current(self.config.key, telem_name)
        message_desc = "Reading current property..."
        message = defs.OutMessage(command, message_desc)

        self.pub_wait = True
        status = self.send(message)
        value = None
        timestamp = None

        # Wait for response from sending to cloud
        while self.pub_wait:
            sleep(0.5)
        # Convert to return codes
        if self.pub_response:
            ret = constants.STATUS_SUCCESS
        else:
            ret = constants.STATUS_FAILURE

        # make sure the key exists or there will be a KeyError
        # exception
        if 'telemetry_current_value' in self.response.keys():
            value = self.response['telemetry_current_value']

        if 'telemetry_current_timestamp' in self.response.keys():
            timestamp = self.response['telemetry_current_timestamp']
        return ret, value, timestamp


    def is_connected(self):
        """
        Returns connection status of Client to Cloud

        """
        return self.state == constants.STATE_CONNECTED


    def log_level(self, log_level=None):
        """
        Set Logging Level

        """
        if log_level:
            if log_level in ('CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'LOG', 'WARNING', 'ALL'):
                if log_level == 'ALL':
                    log_number = getattr(logging, 'DEBUG')
                    self.logger.setLevel(log_number)
                    self.logger.warning("log_level set as 'ALL', DEBUG used as default")
                else:
                    log_number = getattr(logging, log_level)
                    self.logger.setLevel(log_number)
                    self.logger.debug("log_level set as %s", log_level)
            else:
                self.logger.setLevel(logging.DEBUG)
                self.logger.warning("log_level not set or invalid, DEBUG used as default")

        # If no log_level set, set as DEBUG
        else:
            self.logger.setLevel(logging.DEBUG)

        #self.logger.critical("This is a critical")
        #self.logger.debug("This is a debug")
        #self.logger.error("This is a error")
        #self.logger.info("This is a info")
        #self.logger.log(logging.INFO, "This is a log with info")
        #self.logger.warning("This is a warning")

    def main_loop(self):
        """
        Main loop for MQTT to send and receive messages, as well as queue work
        for publishing and checking timeouts
        """

        # Continuously loop while connected or connecting
        while not self.to_quit:

            # If disconnected, attempt to reestablish connection
            if self.state == constants.STATE_DISCONNECTED:
                max_time = self.config.keep_alive
                elapsed_time = (datetime.utcnow() -
                                self.last_connected).total_seconds()
                if max_time == 0 or elapsed_time < max_time:
                    try:
                        result = self.mqtt.reconnect()
                        if result == 0:
                            self.logger.debug("Reconnecting...")
                            self.state = constants.STATE_CONNECTING
                    except Exception:
                        sleep(self.config.loop_time)
                else:
                    self.logger.error("No connection after %d seconds, "
                                      "exiting...",
                                      self.config.keep_alive)
                    self.to_quit = True
                    break

            self.mqtt.loop(timeout=self.config.loop_time)

            # Make a work item to publish anything that's pending
            if not self.publish_queue.empty():
                self.queue_work(defs.Work(constants.WORK_PUBLISH, None))

        # One last loop to send out any pending messages
        self.mqtt.loop(timeout=0.1)

        # Disconnect MQTT
        self.mqtt.disconnect()

        # Wait for worker threads to finish.
        for thread in self.worker_threads:
            thread.join()
        self.worker_threads = []

        # On disconnect, show all messages that never received replies
        if len(self.reply_tracker) > 0:
            self.logger.error("These messages never received a reply:")
            for mid, message in self.reply_tracker.items():
                self.logger.error(".... %s - %s", mid,
                                  message.description)

        return constants.STATUS_SUCCESS

    def num_unfinished(self):
        """
        Get number of unfulfilled requests
        """
        return len(self.mqtt._out_messages)

    def on_connect(self, mqtt, userdata, flags, rc):
        """
        Callback when MQTT Client connects to Cloud
        """
        unfinished = self.num_unfinished()
        if (unfinished > 0):
            self.logger.info("%s messages are pending..", unfinished)
        # Check connection result from MQTT
        self.logger.info("MQTT connected: %s", mqttlib.connack_string(rc))
        if rc == 0:
            self.state = constants.STATE_CONNECTED
        else:
            self.state = constants.STATE_DISCONNECTED
            self.last_connected = datetime.utcnow()

    def on_disconnect(self, mqtt, userdata, rc):
        """
        Callback when MQTT Client disconnects from Cloud
        """

        if self.to_quit:
            self.logger.info("MQTT disconnected")
        else:
            self.logger.error("MQTT connection lost. Attempting to reconnect...")
            self.last_connected = datetime.utcnow()
        self.state = constants.STATE_DISCONNECTED

    def on_message(self, mqtt, userdata, msg):
        """
        Callback when MQTT Client receives a message
        """

        message = defs.Message(msg.topic, json.loads(msg.payload.decode()))
        self.logger.debug("Received message on topic \"%s\"\n%s", msg.topic,
                          message)

        # Queue work to handle received message. Don't block main loop with this
        # task.
        work = defs.Work(constants.WORK_MESSAGE, message)
        self.queue_work(work)

    def on_publish(self, mqtt, userdata, mid):
        """
        Notify that a message has been published
        """
        if self.reply_tracker != {}:
            topic_num = self.reply_tracker.pop_mid(mid)
            self.logger.debug("MQTT sent %s", topic_num)

    def qos_level(self, qos_level=None):
        """
        Set QoS Level

        """
        if qos_level in range(0, 2):
            self.qos_level = qos_level
            self.logger.info("qos_level set as %s", self.qos_level)
        else:
            self.logger.warning("qos_level invalid or not set, 1 used as default")
            self.qos_level = 1

    def queue_publish(self, pub):
        """
        Place pub in the publish queue
        """

        self.publish_queue.put(pub)
        return constants.STATUS_SUCCESS

    def queue_work(self, work):
        """
        Place work in the work queue
        """

        self.work_queue.put(work)
        return constants.STATUS_SUCCESS

    def request_publish(self, data, cloud_response):
        """
        Add data to publish queue and wait for cloud response
        """
        current_time = datetime.utcnow()
        end_time = current_time + timedelta(seconds=15)
        timeout = False

        self.pub_wait = cloud_response
        status = self.queue_publish(data)
        if cloud_response:
            status = constants.STATUS_FAILURE
            # Wait for response from sending to cloud
            while self.pub_wait and not self.to_quit:
                current_time = datetime.utcnow()
                if (current_time > end_time):
                    timeout = True
                    break
                else:
                    sleep(0.5)

            # Convert to return codes
            if self.pub_response:
                status = constants.STATUS_SUCCESS
            elif timeout:
                status = constants.STATUS_TIMED_OUT
        return status

    def request_download(self, file_name, file_dest, blocking=False,
                         callback=None, timeout=0, file_global=False):
        """
        Request a C2D file transfer
        """

        current_time = datetime.utcnow()
        end_time = current_time + timedelta(seconds=timeout)

        self.logger.info("Request download of %s", file_name)

        # is file_dest the full path or the parent directory?
        if os.path.isdir(file_dest):
            file_dest = os.path.join(file_dest, file_name)

        # File Transfer object for tracking progress
        transfer = defs.FileTransfer(file_name, file_dest, self.client,
                                     callback=callback)

        # Generate and send message to request file transfer
        command = tr50.create_file_get(self.config.key, file_name, file_global)
        message = defs.OutMessage(command, "Download {}".format(file_name),
                                  data=transfer)
        status = self.send(message)

        # If blocking is set, wait for result of file transfer
        if status == constants.STATUS_SUCCESS and blocking:
            while ((timeout == 0 or current_time < end_time) and
                   transfer.status is None):
                sleep(0.1)
                current_time = datetime.utcnow()

            if transfer.status is None:
                status = constants.STATUS_TIMED_OUT
            else:
                status = transfer.status

        return status

    def request_upload(self, file_path, upload_name=None, blocking=False,
                       callback=None, timeout=0, file_global=False):
        """
        Request a D2C file transfer
        """

        status = constants.STATUS_SUCCESS
        current_time = datetime.utcnow()
        end_time = current_time + timedelta(seconds=timeout)
        transfer = None

        self.logger.info("Request upload of %s", file_path)

        # Path must be absolute
        if not os.path.isabs(file_path):
            self.logger.error("Path must be absolute \"%s\"", file_path)
            status = constants.STATUS_NOT_FOUND

        if status == constants.STATUS_SUCCESS:
            # Check if file exists
            if not os.path.isfile(file_path):
                # No file to upload
                self.logger.error("Cannot find file %s. "
                                  "Upload cancelled.", file_path)
                status = constants.STATUS_NOT_FOUND
            else:
                transfer = None
                file_name = os.path.basename(file_path)
                if not upload_name:
                    upload_name = file_name

                # Get file crc32 checksum
                checksum = 0
                with open(file_path, "rb") as up_file:
                    for chunk in up_file:
                        checksum = crc32(chunk, checksum)
                checksum = checksum & 0xffffffff

                # File Transfer object for tracking progress
                transfer = defs.FileTransfer(upload_name, file_path,
                                             self.client,
                                             callback=callback)

                # Generate and send message to request file transfer
                command = tr50.create_file_put(self.config.key, upload_name,
                                               crc32=checksum,
                                               file_global=file_global)
                message_desc = "Upload {} as {}".format(file_name,
                                                        upload_name)
                message = defs.OutMessage(command, message_desc,
                                          data=transfer)
                status = self.send(message)

                # If blocking is set, wait for result of file transfer
                if status == constants.STATUS_SUCCESS and blocking:
                    while ((timeout == 0 or current_time < end_time) and
                           not self.to_quit and transfer.status is None):
                        sleep(0.1)
                        current_time = datetime.utcnow()

                    if transfer.status is None:
                        status = constants.STATUS_TIMED_OUT
                    else:
                        status = transfer.status

        return status

    def send(self, messages):
        """
        Send commands to the Cloud, and track them to wait for replies
        """
        status = constants.STATUS_FAILURE

        message_list = messages
        if messages.__class__.__name__ != "list":
            message_list = [messages]

        # Generate final request string
        payload = tr50.generate_request([x.command for x in message_list])

        # Lock to ensure all outgoing messages are tracked before handling
        # received messages
        self.lock.acquire()
        try:
            # Obtain new unused topic number
            while True:
                topic_num = "{:0>4}".format(self.topic_counter)
                self.topic_counter += 1
                if topic_num not in self.reply_tracker:
                    break
            self.pub_topic = topic_num
            # -----------------------------------------------------
            # Send payload over MQTT
            # Add small delay here so that we don't cross the API/s
            # threshold
            # -----------------------------------------------------
            sleep(self.client.idle_sleep)
            result, mid = self.mqtt.publish("api/{}".format(topic_num),
                                            payload, qos = self.qos_level)

            # Track the topic this message will send on
            self.reply_tracker.add_mid(mid, topic_num)

            # Current timestamp to mark when message was sent
            current_time = datetime.utcnow()

            # Track each message
            for num, msg in enumerate(message_list):
                # Add timestamps and ids
                msg.timestamp = current_time
                msg.out_id = "{}-{}".format(topic_num, num+1)

                self.reply_tracker.add_message(msg)
                self.logger.info("MQTT queued %s-%d - %s\n%s", topic_num, num+1,
                                 msg, json.dumps(msg.command, indent=2,
                                                 sort_keys=True))
            status = constants.STATUS_SUCCESS

        finally:
            self.lock.release()

        return status

</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="handler.proxy_support" class="name">var <span class="ident">proxy_support</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="handler.is_valid_status">
    <p>def <span class="ident">is_valid_status</span>(</p><p>error_code)</p>
    </div>
    

    
  
    <div class="desc"><p>Check if passed object is a valid status code</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.is_valid_status', this);">Show source &equiv;</a></p>
  <div id="source-handler.is_valid_status" class="source">
    <pre><code>def is_valid_status(error_code):
    """
    Check if passed object is a valid status code
    """

    return (error_code.__class__.__name__ == "int" and
            error_code >= constants.STATUS_SUCCESS and
            error_code <= constants.STATUS_FAILURE)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="handler.status_string">
    <p>def <span class="ident">status_string</span>(</p><p>error_code)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a string describing the error code</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.status_string', this);">Show source &equiv;</a></p>
  <div id="source-handler.status_string" class="source">
    <pre><code>def status_string(error_code):
    """
    Return a string describing the error code
    """

    return constants.STATUS_STRINGS[error_code]
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="handler.Handler" class="name">class <span class="ident">Handler</span></p>
      
  
    <div class="desc"><p>Handles all underlying functionality of the Client</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler" class="source">
    <pre><code>class Handler(object):
    """
    Handles all underlying functionality of the Client
    """

    def __init__(self, config, client):
        # Configuration
        self.config = config

        # Set Client
        self.client = client

        # Set up logging, with optional logging to a specified file
        if self.config.key:
            self.logger = logging.getLogger(self.config.key)
        else:
            self.logger = logging.getLogger("APP NAME HERE")
        log_formatter = logging.Formatter(constants.LOG_FORMAT,
                                          datefmt=constants.LOG_TIME_FORMAT)
        if not self.config.quiet:
            if self.config.use_syslog:
                print ("Logging to syslog...")
                log_handler = logging.handlers.SysLogHandler(address = '/dev/log')
            else:
                log_handler = logging.StreamHandler()
            log_handler.setFormatter(log_formatter)
            self.logger.addHandler(log_handler)

        if self.config.log_file:
            log_file_handler = logging.FileHandler(self.config.log_file)
            log_file_handler.setFormatter(log_formatter)
            self.logger.addHandler(log_file_handler)

        # Ensure we're not missing required configuration information
        if not self.config.key or not self.config.cloud.token:
            self.logger.error("Missing key or cloud token from configuration")
            raise KeyError("Missing key or cloud token from configuration")

        #log_level default set as DEBUG
        self.logger.setLevel(logging.DEBUG)
        self.qos_level(self.config.qos_level)

        # Print configuration
        self.logger.debug("CONFIG:\n%s", self.config)

        # Ensure the paho socket pair is not using proxy sockets
        # Save the original socket so that class members can use it,
        # e.g. remote login etc.
        socket.socket = original_socket
        self.original_socket = original_socket

        # Set up MQTT client
        if self.config.cloud.port == 443:
            self.mqtt = mqttlib.Client(self.config.key, transport="websockets")
        else:
            self.mqtt = mqttlib.Client(self.config.key)
        self.mqtt.on_connect = self.on_connect
        self.mqtt.on_disconnect = self.on_disconnect
        self.mqtt.on_message = self.on_message
        self.mqtt.on_publish = self.on_publish
        self.mqtt.username_pw_set(self.config.key, self.config.cloud.token)

        # Set up proxy.  Note: PySocks is required for this, but it is
        # an optional pkg.  Check for it.
        if (proxy_support == True):
            if ("host" in self.config.proxy):
                proxy_type = None
                if self.config.proxy.type.upper() == "SOCKS4":
                    proxy_type = socks.SOCKS4
                elif self.config.proxy.type.upper() == "SOCKS5":
                    proxy_type = socks.SOCKS5
                elif self.config.proxy.type.upper() == "HTTP":
                    proxy_type = socks.HTTP
                else:
                    self.logger.error("Invalid proxy type. Supported types are "
                              "SOCKS4/SOCKS5/HTTP.")
                    raise KeyError("Invalid proxy type. Supported types are "
                           "SOCKS4/SOCKS5/HTTP.")
                username = None
                if "username" in self.config.proxy:
                    username = self.config.proxy.username
                password = None
                if "password" in self.config.proxy:
                    password = self.config.proxy.password
                socks.set_default_proxy(proxy_type, self.config.proxy.host,
                            self.config.proxy.port, True, username,
                            password)
                socket.socket = socks.socksocket
        elif ("host" in self.config.proxy and proxy_support == False):
            self.logger.error("PySocks module required for proxy support "
                     "Install PySocks.")
            raise KeyError("PySocks module required for proxy support "
                    "Install PySocks.")

        # Dict to associate action names with callback functions and any user
        # data
        self.callbacks = defs.Callbacks()

        # Connection state of the Client
        self.state = constants.STATE_DISCONNECTED

        # Track last time the app was connected so keep alive can time out
        self.last_connected = datetime.utcnow()

        # Lock for thread safety
        self.lock = threading.Lock()

        # Queue for any pending publishes (number, string, location, etc.)
        self.publish_queue = queue.Queue()

        # Dicts to track which messages sent out have not received replies. Also
        # stores any actions to be taken when the reply is received.
        self.reply_tracker = defs.OutTracker()
        self.no_reply = []

        # Counter to allow every message to be sent on a unique topic
        self.topic_counter = 1

        # Flag for notifying client to exit
        self.to_quit = True

        # Telemetry Response Flag
        self.pub_wait = self.pub_response = False
        self.pub_topic = '0000'

        # Thread trackers. Main thread for handling MQTT loop, and worker
        # threads for everything else.
        self.main_thread = None
        self.worker_threads = []

        # Queue to track any pending work (parsing messages, actions,
        # publishing, file transfer, etc.)
        self.work_queue = queue.Queue()

        # store any requested data here
        self.response = {}

    def action_deregister(self, action_name):
        """
        Disassociate any function or command from an action in the Cloud
        """

        status = constants.STATUS_SUCCESS

        try:
            self.callbacks.remove_action(action_name)
        except KeyError as error:
            self.logger.error(str(error))
            status = constants.STATUS_NOT_FOUND

        return status

    def action_acknowledge(self, request_id, error_code, error_message):
        """
        Send acknowledgement for action (method) request by the cloud
        """

        cmd = tr50.create_mailbox_ack(request_id, error_code, error_message)
        message = defs.OutMessage(cmd, "Action Acknowledge "
                                       "{} {}: \"{}\"".format(request_id,
                                                              error_code,
                                                              error_message))
        return self.send(message)

    def action_progress_update(self, request_id, message):
        """
        Update message for action (method) request in Cloud
        """

        cmd = tr50.create_mailbox_update(request_id, message)
        message = defs.OutMessage(cmd, "Update Action Progress "
                                  "{} \"{}\"".format(request_id, message))
        return self.send(message)

    def action_register_callback(self, action_name, callback_function,
                                 user_data=None):
        """
        Associate a callback function with an action in the Cloud
        """
        status = constants.STATUS_SUCCESS
        action = defs.Action(action_name, callback_function, self.client,
                             user_data=user_data)
        try:
            self.callbacks.add_action(action)
            self.logger.info("Registered action \"%s\" with function \"%s\"",
                             action_name, callback_function.__name__)
        except KeyError as error:
            self.logger.error("Failed to register action. %s", str(error))
            status = constants.STATUS_EXISTS

        return status

    def action_register_command(self, action_name, command):
        """
        Associate a console command with an action in the Cloud
        """

        status = constants.STATUS_SUCCESS
        action = defs.ActionCommand(action_name, command, self.client)
        try:
            self.callbacks.add_action(action)
            self.logger.info("Registered action \"%s\" with command \"%s\"",
                             action_name, command)
        except KeyError as error:
            self.logger.error("Failed to register action. %s", str(error))
            status = constants.STATUS_EXISTS

        return status

    def connect(self, timeout=0):
        """
        Connect to MQTT and start main thread
        """

        self.to_quit = False
        status = constants.STATUS_FAILURE
        result = -1

        # Ensure we have a host and port to connect to
        if not self.config.cloud.host or not self.config.cloud.port:
            self.logger.error("Missing host or port from configuration")
            status = constants.STATUS_BAD_PARAMETER

        else:
            current_time = datetime.utcnow()
            end_time = current_time + timedelta(seconds=timeout)
            self.state = constants.STATE_CONNECTING

            # Add network check and poll here while it is not
            # available.  Otherwise, the service will exit which is
            # not ideal if you do not have a service monitor like
            # systemd.
            test_network = True
            self.logger.info("Checking for network connectivity...")
            while test_network:
                try:
                    ret = socket.gethostbyname(self.config.cloud.host)
                    if ret:
                        self.logger.info("Network is active" )
                        test_network = False
                except socket.error as err:
                    self.logger.error("Network error detected: %s" % str(err))
                    sleep(1)

            # Start a secure connection if using a secure port and the cert file
            # is available
            if self.config.cloud.port in constants.SECURE_PORTS:
                if self.config.validate_cloud_cert is False:
                    context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
                    context.verify_mode = ssl.CERT_NONE
                    context.check_hostname = False
                    self.mqtt.tls_set_context(context)
                elif not self.config.ca_bundle_file:
                    self.logger.error("Missing certificate bundle from configuration")
                    status = constants.STATUS_BAD_PARAMETER
                elif not os.path.isfile(self.config.ca_bundle_file):
                    self.logger.error("Certificate bundle not found")
                    status = constants.STATUS_NOT_FOUND
                else:
                    context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
                    context.load_verify_locations(cafile=self.config.ca_bundle_file)
                    context.verify_mode = ssl.CERT_REQUIRED
                    context.check_hostname = True
                    self.mqtt.tls_set_context(context)

            # status != bad_parameter or not_found
            if status == constants.STATUS_FAILURE:
                # Start MQTT connection
                try:
                    result = self.mqtt.connect(self.config.cloud.host,
                                               self.config.cloud.port, 60)
                except Exception as error:
                    # socket.gaierror or ssl.SSLError
                    self.state = constants.STATE_DISCONNECTED
                    self.logger.error(str(error))

        if result == 0:
            # Successful MQTT connection
            self.logger.info("Connecting...")

            # Start main loop thread so that MQTT can make the on_connect
            # callback
            self.main_thread = threading.Thread(target=self.main_loop)
            self.main_thread.start()

            # Wait for cloud connection
            while ((timeout == 0 or current_time < end_time) and
                   self.state == constants.STATE_CONNECTING):
                sleep(0.1)
                current_time = datetime.utcnow()

            # Still connecting, timed out
            if self.state == constants.STATE_CONNECTING:
                self.logger.error("Connection timed out")
                status = constants.STATUS_TIMED_OUT

        if self.state == constants.STATE_CONNECTED:
            # Connected Successfully
            status = constants.STATUS_SUCCESS

            # Start worker threads if we have successfully connected
            for _ in range(self.config.thread_count):
                self.worker_threads.append(threading.Thread(
                    target=self.handle_work_loop))
            for thread in self.worker_threads:
                thread.start()

        else:
            # Not connected. Stop main loop.
            self.logger.error("Failed to connect")
            self.to_quit = True
            self.state = constants.STATE_DISCONNECTED
            if self.main_thread:
                self.main_thread.join()
                self.main_thread = None

        # Return result of connection
        return status

    def disconnect(self, wait_for_replies=False, timeout=0):
        """
        Stop threads and shut down MQTT client
        """

        current_time = datetime.utcnow()
        end_time = current_time + timedelta(seconds=timeout)

        # Publish any data that was queued before disconnecting
        if not self.publish_queue.empty():
            self.queue_work(defs.Work(constants.WORK_PUBLISH, None))

        # Wait for pending work that has not been dealt with
        self.logger.info("Disconnecting...")
        while ((timeout == 0 or current_time < end_time) and
               not self.work_queue.empty()):
            sleep(0.1)
            current_time = datetime.utcnow()

        # Optionally wait for any outstanding replies.
        if wait_for_replies and self.is_connected():
            self.logger.info("Waiting for replies...")
            while ((timeout == 0 or current_time < end_time) and
                   len(self.reply_tracker) != 0):
                sleep(0.1)
                current_time = datetime.utcnow()

        self.to_quit = True
        #TODO: Kill any hanging threads
        if threading.current_thread() not in self.worker_threads:
            if self.main_thread:
                self.main_thread.join()
                self.main_thread = None

        return constants.STATUS_SUCCESS

    def handle_action(self, action_request):
        """
        Handle action execution requests from Cloud
        """

        result_code = -1
        result_args = {"mail_id":action_request.request_id}
        action_result = None
        action_failed = False

        try:
            # Execute callback
            action_result = self.callbacks.execute_action(action_request)

        except Exception as error:
            # Error with action execution. Might not have been registered.
            action_failed = True
            self.logger.error("Action %s execution failed", action_request.name)
            self.logger.error(".... %s", str(error))
            result_code = constants.STATUS_FAILURE
            result_args["error_message"] = "ERROR: {}".format(str(error))
            if action_request.name not in self.callbacks:
                result_code = constants.STATUS_NOT_FOUND
            else:
                self.logger.exception("Exception:")

        # Action execution did not raise an error
        if not action_failed:
            # Handle returning a tuple or just a status code
            if action_result.__class__.__name__ == "tuple":
                result_code = action_result[0]
                if len(action_result) >= 2:
                    result_args["error_message"] = str(action_result[1])
                if len(action_result) >= 3:
                    result_args["params"] = action_result[2]
            else:
                result_code = action_result

            if not is_valid_status(result_code):
                # Returned 'status' is not a valid status
                error_string = ("Invalid return status: " +
                                str(result_code))
                self.logger.error(error_string)
                result_code = constants.STATUS_BAD_PARAMETER
                result_args["error_message"] = "ERROR: " + error_string

        # Return status to Cloud
        # Check for invoked status.  If so, return mail box update not
        # ack.  Ack is the final notification.  This breaks triggers
        # etc because it doesn't update the status.
        result_args["error_code"] = tr50.translate_error_code(result_code)
        if result_code == constants.STATUS_INVOKED:
                update_args = {"mail_id":action_request.request_id}
                update_args["message"] = "Invoked"
                mailbox_ack = tr50.create_mailbox_update(**update_args)
        else:
                mailbox_ack = tr50.create_mailbox_ack(**result_args)

        message_desc = "Action Complete \"{}\"".format(action_request.name)
        message_desc += " result : {}({})".format(result_code,
                                                  status_string(result_code))
        if result_args.get("error_message"):
            message_desc += " \"{}\"".format(result_args["error_message"])
        if result_args.get("params"):
            message_desc += " \"{}\"".format(str(result_args["params"]))
        message = defs.OutMessage(mailbox_ack, message_desc)
        status = self.send(message)
        return status

    def handle_attribute_get(self, attribute_name ):
        command = tr50.create_attribute_current(self.config.key, attribute_name)
        message_desc = "Reading current attribute..."
        message = defs.OutMessage(command, message_desc)

        self.pub_wait = True
        status = self.send(message)
        value = None
        timestamp = None

        # Wait for response from sending to cloud
        while self.pub_wait:
            sleep(0.5)
        # Convert to return codes
        if self.pub_response:
            ret = constants.STATUS_SUCCESS
        else:
            ret = constants.STATUS_FAILURE

        # make sure the key exists or there will be a KeyError
        # exception
        if 'attribute_current_value' in self.response.keys():
            value = self.response['attribute_current_value']

        if 'attribute_current_timestamp' in self.response.keys():
            timestamp = self.response['attribute_current_timestamp']
        return ret, value, timestamp

    def calc_file_checksum(self, file_name):
        """
        Calculate the crc32 checksum on a file and return the string
        interpretation of it.  Checksum of None means it failed.
        """
        sample = 0
        checksum = None
        if os.path.exists(file_name):
            for chunk in open(file_name, "rb"):
                sample = crc32(chunk, sample)
            checksum = "%s" % (sample & 0xffffffff)
        return checksum

    def do_file_get(self, url, validate, file_xfer_obj):
        """
        Perform a get on the specified file.  Handle all errors and
        exceptions and resumuption from where the download left off.
        """
        response = None

        # -------------------------------------------------------
        # Resume download:
        # -the .part file should exist, but if it doesn't force a
        # clean download
        # -for resume, set the Range header for resume
        # -set the file args to append or overwrite mode
        # -------------------------------------------------------
        if file_xfer_obj.resume_download and os.path.exists(file_xfer_obj.download_temp_path):
            resume_from = os.path.getsize(file_xfer_obj.download_temp_path)
            hdrs = {'Range':'bytes=%s-' % resume_from}
            self.logger.info("Resuming download of %s from %d bytes",
                file_xfer_obj.download_temp_path, resume_from )
            file_args = "ab"
        else:
            hdrs = {}
            file_args = "wb"

        # ---------------------------------------------------------
        # Downloading:
        # -start the download, validate and check use a connectivity
        # timeout so that we can quickly be notified and retry
        # -iterate and write chunks to file
        # -print out progress % but throttle it so that it doesn't
        # overwhelm the system, e.g. progress % 100 == 0
        # -crc32 must be added intrementally and compared later
        # -handle connection and http exceptions
        # -make sure not to retry on http errors > 400
        # -throttle printouts
        # ---------------------------------------------------------
        proxies = self.get_proxy_settings()
        response = requests.get(url, stream=True, verify=validate, timeout=3,
             headers=hdrs, proxies=proxies)
        self.logger.debug("HTTP Status %s" % response.status_code)
        if response.status_code == 200 or response.status_code == 206:
            count = 0
            download_len = 0
            chunk_size = 4096
            with open(file_xfer_obj.download_temp_path, file_args) as temp_file:
                try:
                    for chunk in response.iter_content(chunk_size):
                        if not chunk:
                            break
                        temp_file.write(chunk)
                        if count % 100 == 0:
                            download_len = int(os.path.getsize(file_xfer_obj.download_temp_path))
                            progress = 100 * (float(download_len)/file_xfer_obj.file_size)
                            self.logger.debug("Download progress %0.2f(%%)",
                                 float(progress))
                        count +=1
                except (Exception) as e:
                    self.logger.error("Exception: %s",str(e))
            response.close()
            temp_file.close()

            # -------------------------------------------------------------
            # Validation phase:
            # -if checksums match, move/rename temporary file to real file name
            # Windows requires the target file to be removed if it
            # exists
            # -if the file size is not correct, retry
            # -if the checksum is not correct, fatal, meaning we
            # downloaded everything correctly but the file content is not
            # correct.  No way to recover, just return failure.
            # -------------------------------------------------------------
            checksum = self.calc_file_checksum(file_xfer_obj.download_temp_path)
            self.logger.debug("Checksum calculated=%s, checksum expected %s",
                checksum, file_xfer_obj.file_checksum)
            if (file_xfer_obj.file_checksum == None) or (checksum == str(file_xfer_obj.file_checksum)):
                self.logger.info("Checksum is correct")
                try:
                    os.rename(file_xfer_obj.download_temp_path, file_xfer_obj.file_path)
                except:
                    os.remove(file_xfer_obj.file_path)
                    os.rename(file_xfer_obj.download_temp_path, file_xfer_obj.file_path)
                self.logger.info("Successfully downloaded %s", file_xfer_obj.file_name)
                status = constants.STATUS_SUCCESS
            elif download_len != file_xfer_obj.file_size:
                self.logger.error("Download was interrupted, trying again")
                status = constants.STATUS_TRY_AGAIN
            else:
                self.logger.error("Fatal error: download completed but checksum"
                   " does not match expected.  Deleting file.")
                os.remove(file_xfer_obj.download_temp_path)
                status = constants.STATUS_FAILURE

        elif response.status_code >= 400:
            self.logger.error("A fatal HTTP error occurred: %s", response.reason)
            status = constants.STATUS_FAILURE
        else:
            self.logger.error("File transfer interrupted.  Trying again.")
            status = constants.STATUS_TRY_AGAIN
        return status

    def handle_file_download(self, file_xfer_obj):
        """
        Handle any accepted C2D file transfers
        """
        # -----------------------------------------------------------
        # File download handler:
        # -prepare for a file download, create temp file, make sure
        # all directories exist.
        # -call do_file_get in a loop unless we get a STATUS_FAILURE,
        # which means it is fatal.
        # -----------------------------------------------------------
        status = constants.STATUS_SUCCESS
        self.logger.info("Downloading \"%s\"", file_xfer_obj.file_name)
        self.logger.info("File size \"%d\"", file_xfer_obj.file_size)
        url = "https://{}/file/{}".format(self.config.cloud.host, file_xfer_obj.file_id)
        download_dir = os.path.dirname(file_xfer_obj.file_path)
        temp_file_name = "".join([random.choice("0123456789") for _ in range(10)])
        temp_file_name += ".part"
        temp_path = os.path.join(download_dir, temp_file_name)
        file_xfer_obj.download_temp_path = temp_path

        if not os.path.exists(download_dir):
            try:
                os.makedirs(download_dir)
            except OSError as err:
                self.logger.exception(err)
                status = constants.STATUS_BAD_PARAMETER
        elif not os.path.isdir(download_dir):
            self.logger.error("Failed to download %s (destination error)",
                              file_xfer_obj.file_name)
            status = constants.STATUS_IO_ERROR

        if status == constants.STATUS_SUCCESS:
            if (self.config.validate_cloud_cert is False or
                    not self.config.ca_bundle_file or
                    not os.path.isfile(self.config.ca_bundle_file)):
                validate = False
            else:
                validate = self.config.validate_cloud_cert

            # ----------
            # Retry loop
            # ----------
            status = self.do_file_get(url, validate, file_xfer_obj)
            while (status == constants.STATUS_TRY_AGAIN ):
                file_xfer_obj.resume_download = True
                status = self.do_file_get(url, validate, file_xfer_obj)
                sleep(1)

        file_xfer_obj.status = status
        file_xfer_obj.finish()
        return status

    def get_proxy_settings(self):
        if self.config.proxy:
            self.logger.debug("Proxy support detected")
            self.logger.debug("\ttype {} host {} port {}"
                .format(self.config.proxy.type,
                self.config.proxy.host,
                str(self.config.proxy.port )))

            proxy_host = self.config.proxy.host + ':' + str(self.config.proxy.port)
            proxy_type = self.config.proxy.type.lower()

            proxy_auth = ""

            # setup auth
            if self.config.proxy.username:
                proxy_auth = self.config.proxy.username
            if self.config.proxy.password:
                proxy_auth += ':' + self.config.proxy.password
                proxy_auth += '@'

            # key type is always http.  There is a bug when using
            # https.  The proxy tries to do a connect and fails with a
            # 403 error.
            proxies = {
                'http':  proxy_type + '://' + proxy_auth + proxy_host
            }
        else:
            proxies = None

        return proxies

    def handle_file_upload(self, upload):
        """
        Handle any accepted D2C file transfers
        """

        #TODO: Timeout

        status = constants.STATUS_SUCCESS

        self.logger.info("Uploading \"%s\" as \"%s\"",
                         os.path.basename(upload.file_path), upload.file_name)

        # Start creating URL for file upload
        url = "https://{}/file/{}".format(self.config.cloud.host,
                                          upload.file_id)

        response = None
        proxies = self.get_proxy_settings()

        if os.path.exists(upload.file_path):
            # If file exists attempt upload
            with open(upload.file_path, "rb") as up_file:
                # Secure or insecure HTTPS Post
                if (self.config.validate_cloud_cert is False or
                        not self.config.ca_bundle_file):
                    response = requests.post(url, data=up_file,
                    verify=False, proxies=proxies)
                else:
                    cert_location = self.config.ca_bundle_file
                    response = requests.post(url, data=up_file,
                                             verify=cert_location,
                                             proxies=proxies)

            if response.status_code == 200:
                self.logger.info("Successfully uploaded \"%s\"",
                                 upload.file_name)
                status = constants.STATUS_SUCCESS
            else:
                self.logger.error("Failed to upload \"%s\"",
                                  upload.file_name)
                self.logger.debug(".... %s", response.content)
                status = constants.STATUS_FAILURE

        else:
            # File does not exist
            self.logger.error("Cannot find file \"%s\". Upload failed.",
                              upload.file_path)
            status = constants.STATUS_NOT_FOUND

        # Update file transfer status
        upload.status = status

        # Call callback if it exists
        upload.finish()

        return status

    def handle_message(self, mqtt_message):
        """
        Handle messages received from Cloud
        """

        status = constants.STATUS_NOT_SUPPORTED

        msg_json = mqtt_message.json
        if "notify/" in mqtt_message.topic:
            # Received a notification
            if mqtt_message.topic[len("notify/"):] == "mailbox_activity":
                # Mailbox activity, send a request to check the mailbox
                self.logger.info("Recevied notification of mailbox activity")
                mailbox_check = tr50.create_mailbox_check(auto_complete=False)
                to_send = defs.OutMessage(mailbox_check, "Mailbox Check")
                self.send(to_send)
                status = constants.STATUS_SUCCESS

        elif "reply/" in mqtt_message.topic:
            # Received a reply to a previous message
            topic_num = mqtt_message.topic[len("reply/"):]
            for command_num in msg_json:
                reply = msg_json[command_num]

                # Retrieve the sent message that this is a reply for, removing
                # it from being tracked
                self.lock.acquire()
                try:
                    sent_message = self.reply_tracker.pop_message(topic_num,
                                                                  command_num)
                except KeyError as error:
                    self.logger.error(error.message)
                    continue
                finally:
                    self.lock.release()
                sent_command_type = sent_message.command.get("command")

                # Log success status of reply
                if reply.get("success"):
                    self.logger.info("Received success for %s-%s - %s",
                                     topic_num, command_num, sent_message)
                else:
                    self.logger.error("Received failure for %s-%s - %s",
                                      topic_num, command_num, sent_message)
                    self.logger.error(".... %s", str(reply))

                    if self.client.error_handler:
                        self.client.error_handler(
                        reply.get("errorCodes", []),
                        sent_message,
                        str(reply))

                # Return "success" status
                if self.pub_wait:
                    if self.pub_topic == topic_num:
                        self.pub_response = reply.get("success")
                        self.pub_wait = False
                    else:
                        self.pub_wait = self.pub_response = False

                # Check what kind of message this is a reply to
                if sent_command_type == TR50Command.file_get:
                    # Recevied a reply for a file download request
                    if reply.get("success"):
                        file_id = reply["params"].get("fileId")
                        file_checksum = reply["params"].get("crc32")
                        file_size = reply["params"].get("fileSize")
                        file_transfer = sent_message.data
                        file_transfer.file_id = file_id
                        file_transfer.file_checksum = file_checksum
                        file_transfer.file_size = file_size
                        work = defs.Work(constants.WORK_DOWNLOAD, file_transfer)
                        self.queue_work(work)
                    else:
                        if -90008 in reply.get("errorCodes", []):
                            sent_message.data.status = constants.STATUS_NOT_FOUND
                        elif sent_message.data != None:
                            sent_message.data.status = constants.STATUS_FAILURE

                elif sent_command_type == TR50Command.file_put:
                    # Received a reply for a file upload request
                    if reply.get("success"):
                        file_id = reply["params"].get("fileId")
                        file_transfer = sent_message.data
                        file_transfer.file_id = file_id
                        work = defs.Work(constants.WORK_UPLOAD, file_transfer)
                        self.queue_work(work)
                    else:
                        sent_message.data.status = constants.STATUS_FAILURE

                elif sent_command_type == TR50Command.mailbox_check:
                    # Received a reply for a mailbox check
                    if reply.get("success"):
                        try:
                            for mail in reply["params"]["messages"]:
                                mail_command = mail.get("command")
                                if mail_command == "method.exec":
                                    # Action execute request in mailbox
                                    mail_id = mail.get("id")
                                    action_name = mail["params"].get("method")
                                    action_params = mail["params"].get("params")
                                    action_request = defs.ActionRequest(mail_id,
                                                                        action_name,
                                                                        action_params)
                                    work = defs.Work(constants.WORK_ACTION,
                                                     action_request)
                                    self.queue_work(work)
                        except:
                            pass
                elif sent_command_type == TR50Command.diag_time:
                    # Recevied a reply for a ping request
                    if reply.get("success"):
                        mill = reply["params"].get("time")
                        print (datetime.fromtimestamp(mill/1000.0))

                    else:
                        if -90008 in reply.get("errorCodes", []):
                            sent_message.data.status = constants.STATUS_NOT_FOUND
                        else:
                            sent_message.data.status = constants.STATUS_FAILURE

                elif sent_command_type == TR50Command.diag_ping:
                    # Recevied a reply for a ping request
                    if reply.get("success"):
                       print ('*Connection Okay* \n')
                    else:
                        if -90008 in reply.get("errorCodes", []):
                            sent_message.data.status = constants.STATUS_NOT_FOUND
                        else:
                            sent_message.data.status = constants.STATUS_FAILURE

                elif sent_command_type == TR50Command.property_current:
                    # Recevied a reply for a ping request
                    if reply.get("success"):
                       params = reply.get("params")
                       self.response['telemetry_current_value'] = params.get("value")
                       self.response['telemetry_current_timestamp'] = params.get("ts")
                    else:
                        if -90008 in reply.get("errorCodes", []):
                            sent_message.data.status = constants.STATUS_NOT_FOUND
                        elif sent_message.data != None:
                            sent_message.data.status = constants.STATUS_FAILURE
                elif sent_command_type == TR50Command.attribute_current:
                    # Recevied a reply for a ping request
                    if reply.get("success"):
                       params = reply.get("params")
                       self.response['attribute_current_value']  = params.get("value")
                       self.response['attribute_current_timestamp']  = params.get("ts")
                    else:
                        if -90008 in reply.get("errorCodes", []):
                            sent_message.data.status = constants.STATUS_NOT_FOUND
                        elif  sent_message.data != None:
                            sent_message.data.status = constants.STATUS_FAILURE
            status = constants.STATUS_SUCCESS

        return status

    def handle_publish(self):
        """
        Publish any pending publishes in the publish queue, or the cloud logger
        """

        status = constants.STATUS_SUCCESS

        # Collect all pending publishes in publish queue
        to_publish = []
        while not self.publish_queue.empty():
            try:
                to_publish.append(self.publish_queue.get())
            except queue.Empty:
                break

        if to_publish:
            # If pending publishes are found, parse into list for sending
            messages = []
            batch = {}
            batch['PublishAlarm'] = []
            batch['PublishAttribute'] = []
            batch['PublishTelemetry'] = []
            batch['PublishLocation'] = []
            batch['PublishLog'] = []
            for pub in to_publish:
                message = None
                # ------------------
                # Alarms
                # ------------------
                if pub.type == "PublishAlarm":
                    batch[pub.type].append(
                        tr50.create_alarm_batch_item(
                            pub.name,
                            pub.state,
                            pub.timestamp,
                            pub.message,
                            pub.republish))

                # ------------------
                # Attributes
                # ------------------
                elif pub.type == "PublishAttribute":
                    batch[pub.type].append(
                        tr50.create_attribute_batch_item(
                            pub.name,
                            pub.value,
                            pub.timestamp))

                elif pub.type == "PublishTelemetry":
                    batch[pub.type].append(
                        tr50.create_property_batch_item(
                            pub.name,
                            pub.value,
                            pub.timestamp ))

                # ------------------
                # Location
                # ------------------
                elif pub.type == "PublishLocation":
                    batch[pub.type].append(
                        tr50.create_location_batch_item(
                            pub.latitude,
                            pub.longitude,
                            pub.heading,
                            pub.altitude,
                            pub.speed,
                            pub.accuracy,
                            pub.fix_type,
                            pub.timestamp))

                # ------------------
                # Event logs
                # ------------------
                elif pub.type == "PublishLog":
                    command = tr50.create_log_publish(self.config.key,
                                                      pub.message,
                                                      timestamp=pub.timestamp)
                    message_desc = "Log Publish {}".format(pub.message)
                    message = defs.OutMessage(command, message_desc)

                if message:
                    messages.append(message)

            # Send all publishes
            if messages:
                status = self.send(messages)

            # send out batches
            if batch['PublishAlarm']:
                timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
                command = tr50.create_alarm_publish(self.config.key,
                                                    "alarm_batch",
                                                    "Alarm Batch",
                                                    timestamp=timestamp,
                                                    republish=False,
                                                    batch=True)
                message_desc = "Alarm Publish {}".format("alarm_batch")
                message_desc += " : \"{}\"".format("Alarm Batch")
                batch_msg = defs.OutMessage(command, message_desc)
                batch_msg.command['params']['state'] = 0
                batch_msg.command['params']['data'] = batch['PublishAlarm']
                status = self.send(batch_msg)

            if batch['PublishAttribute']:
                timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
                command = tr50.create_attribute_publish(self.config.key,
                                                        "attribute_batch",
                                                        "Attribute Batch",
                                                        timestamp=timestamp,
                                                        batch=True)
                message_desc = "Attribute Publish {}".format("attribute_batch")
                message_desc += " : \"{}\"".format("Attribute Batch")
                batch_msg = defs.OutMessage(command, message_desc)
                batch_msg.command['params']['data'] = batch['PublishAttribute']
                status = self.send(batch_msg)

            if batch['PublishLocation']:
                timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
                command = tr50.create_location_publish(self.config.key,
                                                        "location_batch",
                                                        "Location Batch",
                                                        timestamp=timestamp,
                                                        batch=True)
                message_desc = "Location Publish {}".format("location_batch")
                message_desc += " : \"{}\"".format("Location Batch")
                batch_msg = defs.OutMessage(command, message_desc)
                batch_msg.command['params']['data'] = batch['PublishLocation']
                status = self.send(batch_msg)

            if batch['PublishTelemetry']:
                timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
                command = tr50.create_property_publish(self.config.key,
                                                        "property_batch",
                                                        "Property Batch",
                                                        timestamp=timestamp,
                                                        batch=True)
                message_desc = "Property Publish {}".format("property_batch")
                message_desc += " : \"{}\"".format("Property Batch")
                batch_msgs = defs.OutMessage(command, message_desc)
                batch_msgs.command['params']['data'] =  batch['PublishTelemetry']
                status = self.send(batch_msgs)

        return status

    def handle_work_loop(self):
        """
        Loop for worker threads to handle any items put on the work queue
        """

        # Continuously loop while connected
        while not self.to_quit:
            work = None
            try:
                work = self.work_queue.get(timeout=self.config.loop_time)
            except queue.Empty:
                pass
            # If work is retrieved from the queue, handle it based on type
            if work:
                try:
                    if work.type == constants.WORK_MESSAGE:
                        self.handle_message(work.data)
                    elif work.type == constants.WORK_PUBLISH:
                        self.handle_publish()
                    elif work.type == constants.WORK_ACTION:
                        self.handle_action(work.data)
                    elif work.type == constants.WORK_DOWNLOAD:
                        self.handle_file_download(work.data)
                    elif work.type == constants.WORK_UPLOAD:
                        self.handle_file_upload(work.data)
                except Exception:
                    # Print traceback, but don't kill thread
                    self.logger.exception("Exception:")

        return constants.STATUS_SUCCESS

    def handle_ping(self):
        """
        Request connection check
        """
        command = tr50.create_diag_ping()
        message_desc = "Connected"
        message = defs.OutMessage(command, message_desc)
        status = self.send(message)
        return constants.STATUS_SUCCESS

    def handle_update_thing_details(self, name=None, description=None,
                            iccid=None, esn=None, imei=None, meid=None,
                            imsi=None, unset_fields=[]):
        """
        Request to update a things definition.  The thing key must be
        immutable.  Friendly name and other non connectivity tracking
        keys can be changed, e.g. name, description, ICCID, ESN, IMEI,
        IMSI.
        """
        # if any of the default values are None, unset them in the
        # thing update. Support unsetting members in the thing
        # description.  Maybe remove the unsupported tunnel
        # fields from the thing description TBD.
        unset = []
        list_test = True
        if isinstance(unset_fields, list):
            print("unset_fields is a list of %d items" % len(unset_fields))
            if len(unset_fields) > 0:
                for v in unset_fields:
                    unset.append(v)
        else:
            list_test = False
            status = constants.STATUS_PARSE_ERROR

        if list_test:
            command = tr50.create_thing_update(self.config.key, name,
                            description, iccid, esn, imei, meid, imsi,
                            unset)
            message_desc = "Update Thing Details"
            message = defs.OutMessage(command, message_desc)
            status = self.send(message)
        return status

    def handle_time(self):
        """
        Request time from the cloud
        """
        command = tr50.create_diag_time()
        message_desc = "Retrieving Time.."
        message = defs.OutMessage(command, message_desc)
        status = self.send(message)
        return constants.STATUS_SUCCESS

    def handle_telemetry_get(self, telem_name ):
        """
        Add data to publish queue and wait for cloud response
        """
        command = tr50.create_property_get_current(self.config.key, telem_name)
        message_desc = "Reading current property..."
        message = defs.OutMessage(command, message_desc)

        self.pub_wait = True
        status = self.send(message)
        value = None
        timestamp = None

        # Wait for response from sending to cloud
        while self.pub_wait:
            sleep(0.5)
        # Convert to return codes
        if self.pub_response:
            ret = constants.STATUS_SUCCESS
        else:
            ret = constants.STATUS_FAILURE

        # make sure the key exists or there will be a KeyError
        # exception
        if 'telemetry_current_value' in self.response.keys():
            value = self.response['telemetry_current_value']

        if 'telemetry_current_timestamp' in self.response.keys():
            timestamp = self.response['telemetry_current_timestamp']
        return ret, value, timestamp


    def is_connected(self):
        """
        Returns connection status of Client to Cloud

        """
        return self.state == constants.STATE_CONNECTED


    def log_level(self, log_level=None):
        """
        Set Logging Level

        """
        if log_level:
            if log_level in ('CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'LOG', 'WARNING', 'ALL'):
                if log_level == 'ALL':
                    log_number = getattr(logging, 'DEBUG')
                    self.logger.setLevel(log_number)
                    self.logger.warning("log_level set as 'ALL', DEBUG used as default")
                else:
                    log_number = getattr(logging, log_level)
                    self.logger.setLevel(log_number)
                    self.logger.debug("log_level set as %s", log_level)
            else:
                self.logger.setLevel(logging.DEBUG)
                self.logger.warning("log_level not set or invalid, DEBUG used as default")

        # If no log_level set, set as DEBUG
        else:
            self.logger.setLevel(logging.DEBUG)

        #self.logger.critical("This is a critical")
        #self.logger.debug("This is a debug")
        #self.logger.error("This is a error")
        #self.logger.info("This is a info")
        #self.logger.log(logging.INFO, "This is a log with info")
        #self.logger.warning("This is a warning")

    def main_loop(self):
        """
        Main loop for MQTT to send and receive messages, as well as queue work
        for publishing and checking timeouts
        """

        # Continuously loop while connected or connecting
        while not self.to_quit:

            # If disconnected, attempt to reestablish connection
            if self.state == constants.STATE_DISCONNECTED:
                max_time = self.config.keep_alive
                elapsed_time = (datetime.utcnow() -
                                self.last_connected).total_seconds()
                if max_time == 0 or elapsed_time < max_time:
                    try:
                        result = self.mqtt.reconnect()
                        if result == 0:
                            self.logger.debug("Reconnecting...")
                            self.state = constants.STATE_CONNECTING
                    except Exception:
                        sleep(self.config.loop_time)
                else:
                    self.logger.error("No connection after %d seconds, "
                                      "exiting...",
                                      self.config.keep_alive)
                    self.to_quit = True
                    break

            self.mqtt.loop(timeout=self.config.loop_time)

            # Make a work item to publish anything that's pending
            if not self.publish_queue.empty():
                self.queue_work(defs.Work(constants.WORK_PUBLISH, None))

        # One last loop to send out any pending messages
        self.mqtt.loop(timeout=0.1)

        # Disconnect MQTT
        self.mqtt.disconnect()

        # Wait for worker threads to finish.
        for thread in self.worker_threads:
            thread.join()
        self.worker_threads = []

        # On disconnect, show all messages that never received replies
        if len(self.reply_tracker) > 0:
            self.logger.error("These messages never received a reply:")
            for mid, message in self.reply_tracker.items():
                self.logger.error(".... %s - %s", mid,
                                  message.description)

        return constants.STATUS_SUCCESS

    def num_unfinished(self):
        """
        Get number of unfulfilled requests
        """
        return len(self.mqtt._out_messages)

    def on_connect(self, mqtt, userdata, flags, rc):
        """
        Callback when MQTT Client connects to Cloud
        """
        unfinished = self.num_unfinished()
        if (unfinished > 0):
            self.logger.info("%s messages are pending..", unfinished)
        # Check connection result from MQTT
        self.logger.info("MQTT connected: %s", mqttlib.connack_string(rc))
        if rc == 0:
            self.state = constants.STATE_CONNECTED
        else:
            self.state = constants.STATE_DISCONNECTED
            self.last_connected = datetime.utcnow()

    def on_disconnect(self, mqtt, userdata, rc):
        """
        Callback when MQTT Client disconnects from Cloud
        """

        if self.to_quit:
            self.logger.info("MQTT disconnected")
        else:
            self.logger.error("MQTT connection lost. Attempting to reconnect...")
            self.last_connected = datetime.utcnow()
        self.state = constants.STATE_DISCONNECTED

    def on_message(self, mqtt, userdata, msg):
        """
        Callback when MQTT Client receives a message
        """

        message = defs.Message(msg.topic, json.loads(msg.payload.decode()))
        self.logger.debug("Received message on topic \"%s\"\n%s", msg.topic,
                          message)

        # Queue work to handle received message. Don't block main loop with this
        # task.
        work = defs.Work(constants.WORK_MESSAGE, message)
        self.queue_work(work)

    def on_publish(self, mqtt, userdata, mid):
        """
        Notify that a message has been published
        """
        if self.reply_tracker != {}:
            topic_num = self.reply_tracker.pop_mid(mid)
            self.logger.debug("MQTT sent %s", topic_num)

    def qos_level(self, qos_level=None):
        """
        Set QoS Level

        """
        if qos_level in range(0, 2):
            self.qos_level = qos_level
            self.logger.info("qos_level set as %s", self.qos_level)
        else:
            self.logger.warning("qos_level invalid or not set, 1 used as default")
            self.qos_level = 1

    def queue_publish(self, pub):
        """
        Place pub in the publish queue
        """

        self.publish_queue.put(pub)
        return constants.STATUS_SUCCESS

    def queue_work(self, work):
        """
        Place work in the work queue
        """

        self.work_queue.put(work)
        return constants.STATUS_SUCCESS

    def request_publish(self, data, cloud_response):
        """
        Add data to publish queue and wait for cloud response
        """
        current_time = datetime.utcnow()
        end_time = current_time + timedelta(seconds=15)
        timeout = False

        self.pub_wait = cloud_response
        status = self.queue_publish(data)
        if cloud_response:
            status = constants.STATUS_FAILURE
            # Wait for response from sending to cloud
            while self.pub_wait and not self.to_quit:
                current_time = datetime.utcnow()
                if (current_time > end_time):
                    timeout = True
                    break
                else:
                    sleep(0.5)

            # Convert to return codes
            if self.pub_response:
                status = constants.STATUS_SUCCESS
            elif timeout:
                status = constants.STATUS_TIMED_OUT
        return status

    def request_download(self, file_name, file_dest, blocking=False,
                         callback=None, timeout=0, file_global=False):
        """
        Request a C2D file transfer
        """

        current_time = datetime.utcnow()
        end_time = current_time + timedelta(seconds=timeout)

        self.logger.info("Request download of %s", file_name)

        # is file_dest the full path or the parent directory?
        if os.path.isdir(file_dest):
            file_dest = os.path.join(file_dest, file_name)

        # File Transfer object for tracking progress
        transfer = defs.FileTransfer(file_name, file_dest, self.client,
                                     callback=callback)

        # Generate and send message to request file transfer
        command = tr50.create_file_get(self.config.key, file_name, file_global)
        message = defs.OutMessage(command, "Download {}".format(file_name),
                                  data=transfer)
        status = self.send(message)

        # If blocking is set, wait for result of file transfer
        if status == constants.STATUS_SUCCESS and blocking:
            while ((timeout == 0 or current_time < end_time) and
                   transfer.status is None):
                sleep(0.1)
                current_time = datetime.utcnow()

            if transfer.status is None:
                status = constants.STATUS_TIMED_OUT
            else:
                status = transfer.status

        return status

    def request_upload(self, file_path, upload_name=None, blocking=False,
                       callback=None, timeout=0, file_global=False):
        """
        Request a D2C file transfer
        """

        status = constants.STATUS_SUCCESS
        current_time = datetime.utcnow()
        end_time = current_time + timedelta(seconds=timeout)
        transfer = None

        self.logger.info("Request upload of %s", file_path)

        # Path must be absolute
        if not os.path.isabs(file_path):
            self.logger.error("Path must be absolute \"%s\"", file_path)
            status = constants.STATUS_NOT_FOUND

        if status == constants.STATUS_SUCCESS:
            # Check if file exists
            if not os.path.isfile(file_path):
                # No file to upload
                self.logger.error("Cannot find file %s. "
                                  "Upload cancelled.", file_path)
                status = constants.STATUS_NOT_FOUND
            else:
                transfer = None
                file_name = os.path.basename(file_path)
                if not upload_name:
                    upload_name = file_name

                # Get file crc32 checksum
                checksum = 0
                with open(file_path, "rb") as up_file:
                    for chunk in up_file:
                        checksum = crc32(chunk, checksum)
                checksum = checksum & 0xffffffff

                # File Transfer object for tracking progress
                transfer = defs.FileTransfer(upload_name, file_path,
                                             self.client,
                                             callback=callback)

                # Generate and send message to request file transfer
                command = tr50.create_file_put(self.config.key, upload_name,
                                               crc32=checksum,
                                               file_global=file_global)
                message_desc = "Upload {} as {}".format(file_name,
                                                        upload_name)
                message = defs.OutMessage(command, message_desc,
                                          data=transfer)
                status = self.send(message)

                # If blocking is set, wait for result of file transfer
                if status == constants.STATUS_SUCCESS and blocking:
                    while ((timeout == 0 or current_time < end_time) and
                           not self.to_quit and transfer.status is None):
                        sleep(0.1)
                        current_time = datetime.utcnow()

                    if transfer.status is None:
                        status = constants.STATUS_TIMED_OUT
                    else:
                        status = transfer.status

        return status

    def send(self, messages):
        """
        Send commands to the Cloud, and track them to wait for replies
        """
        status = constants.STATUS_FAILURE

        message_list = messages
        if messages.__class__.__name__ != "list":
            message_list = [messages]

        # Generate final request string
        payload = tr50.generate_request([x.command for x in message_list])

        # Lock to ensure all outgoing messages are tracked before handling
        # received messages
        self.lock.acquire()
        try:
            # Obtain new unused topic number
            while True:
                topic_num = "{:0>4}".format(self.topic_counter)
                self.topic_counter += 1
                if topic_num not in self.reply_tracker:
                    break
            self.pub_topic = topic_num
            # -----------------------------------------------------
            # Send payload over MQTT
            # Add small delay here so that we don't cross the API/s
            # threshold
            # -----------------------------------------------------
            sleep(self.client.idle_sleep)
            result, mid = self.mqtt.publish("api/{}".format(topic_num),
                                            payload, qos = self.qos_level)

            # Track the topic this message will send on
            self.reply_tracker.add_mid(mid, topic_num)

            # Current timestamp to mark when message was sent
            current_time = datetime.utcnow()

            # Track each message
            for num, msg in enumerate(message_list):
                # Add timestamps and ids
                msg.timestamp = current_time
                msg.out_id = "{}-{}".format(topic_num, num+1)

                self.reply_tracker.add_message(msg)
                self.logger.info("MQTT queued %s-%d - %s\n%s", topic_num, num+1,
                                 msg, json.dumps(msg.command, indent=2,
                                                 sort_keys=True))
            status = constants.STATUS_SUCCESS

        finally:
            self.lock.release()

        return status
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#handler.Handler">Handler</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="handler.Handler.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, config, client)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.__init__', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.__init__" class="source">
    <pre><code>def __init__(self, config, client):
    # Configuration
    self.config = config
    # Set Client
    self.client = client
    # Set up logging, with optional logging to a specified file
    if self.config.key:
        self.logger = logging.getLogger(self.config.key)
    else:
        self.logger = logging.getLogger("APP NAME HERE")
    log_formatter = logging.Formatter(constants.LOG_FORMAT,
                                      datefmt=constants.LOG_TIME_FORMAT)
    if not self.config.quiet:
        if self.config.use_syslog:
            print ("Logging to syslog...")
            log_handler = logging.handlers.SysLogHandler(address = '/dev/log')
        else:
            log_handler = logging.StreamHandler()
        log_handler.setFormatter(log_formatter)
        self.logger.addHandler(log_handler)
    if self.config.log_file:
        log_file_handler = logging.FileHandler(self.config.log_file)
        log_file_handler.setFormatter(log_formatter)
        self.logger.addHandler(log_file_handler)
    # Ensure we're not missing required configuration information
    if not self.config.key or not self.config.cloud.token:
        self.logger.error("Missing key or cloud token from configuration")
        raise KeyError("Missing key or cloud token from configuration")
    #log_level default set as DEBUG
    self.logger.setLevel(logging.DEBUG)
    self.qos_level(self.config.qos_level)
    # Print configuration
    self.logger.debug("CONFIG:\n%s", self.config)
    # Ensure the paho socket pair is not using proxy sockets
    # Save the original socket so that class members can use it,
    # e.g. remote login etc.
    socket.socket = original_socket
    self.original_socket = original_socket
    # Set up MQTT client
    if self.config.cloud.port == 443:
        self.mqtt = mqttlib.Client(self.config.key, transport="websockets")
    else:
        self.mqtt = mqttlib.Client(self.config.key)
    self.mqtt.on_connect = self.on_connect
    self.mqtt.on_disconnect = self.on_disconnect
    self.mqtt.on_message = self.on_message
    self.mqtt.on_publish = self.on_publish
    self.mqtt.username_pw_set(self.config.key, self.config.cloud.token)
    # Set up proxy.  Note: PySocks is required for this, but it is
    # an optional pkg.  Check for it.
    if (proxy_support == True):
        if ("host" in self.config.proxy):
            proxy_type = None
            if self.config.proxy.type.upper() == "SOCKS4":
                proxy_type = socks.SOCKS4
            elif self.config.proxy.type.upper() == "SOCKS5":
                proxy_type = socks.SOCKS5
            elif self.config.proxy.type.upper() == "HTTP":
                proxy_type = socks.HTTP
            else:
                self.logger.error("Invalid proxy type. Supported types are "
                          "SOCKS4/SOCKS5/HTTP.")
                raise KeyError("Invalid proxy type. Supported types are "
                       "SOCKS4/SOCKS5/HTTP.")
            username = None
            if "username" in self.config.proxy:
                username = self.config.proxy.username
            password = None
            if "password" in self.config.proxy:
                password = self.config.proxy.password
            socks.set_default_proxy(proxy_type, self.config.proxy.host,
                        self.config.proxy.port, True, username,
                        password)
            socket.socket = socks.socksocket
    elif ("host" in self.config.proxy and proxy_support == False):
        self.logger.error("PySocks module required for proxy support "
                 "Install PySocks.")
        raise KeyError("PySocks module required for proxy support "
                "Install PySocks.")
    # Dict to associate action names with callback functions and any user
    # data
    self.callbacks = defs.Callbacks()
    # Connection state of the Client
    self.state = constants.STATE_DISCONNECTED
    # Track last time the app was connected so keep alive can time out
    self.last_connected = datetime.utcnow()
    # Lock for thread safety
    self.lock = threading.Lock()
    # Queue for any pending publishes (number, string, location, etc.)
    self.publish_queue = queue.Queue()
    # Dicts to track which messages sent out have not received replies. Also
    # stores any actions to be taken when the reply is received.
    self.reply_tracker = defs.OutTracker()
    self.no_reply = []
    # Counter to allow every message to be sent on a unique topic
    self.topic_counter = 1
    # Flag for notifying client to exit
    self.to_quit = True
    # Telemetry Response Flag
    self.pub_wait = self.pub_response = False
    self.pub_topic = '0000'
    # Thread trackers. Main thread for handling MQTT loop, and worker
    # threads for everything else.
    self.main_thread = None
    self.worker_threads = []
    # Queue to track any pending work (parsing messages, actions,
    # publishing, file transfer, etc.)
    self.work_queue = queue.Queue()
    # store any requested data here
    self.response = {}
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.action_acknowledge">
    <p>def <span class="ident">action_acknowledge</span>(</p><p>self, request_id, error_code, error_message)</p>
    </div>
    

    
  
    <div class="desc"><p>Send acknowledgement for action (method) request by the cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.action_acknowledge', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.action_acknowledge" class="source">
    <pre><code>def action_acknowledge(self, request_id, error_code, error_message):
    """
    Send acknowledgement for action (method) request by the cloud
    """
    cmd = tr50.create_mailbox_ack(request_id, error_code, error_message)
    message = defs.OutMessage(cmd, "Action Acknowledge "
                                   "{} {}: \"{}\"".format(request_id,
                                                          error_code,
                                                          error_message))
    return self.send(message)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.action_deregister">
    <p>def <span class="ident">action_deregister</span>(</p><p>self, action_name)</p>
    </div>
    

    
  
    <div class="desc"><p>Disassociate any function or command from an action in the Cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.action_deregister', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.action_deregister" class="source">
    <pre><code>def action_deregister(self, action_name):
    """
    Disassociate any function or command from an action in the Cloud
    """
    status = constants.STATUS_SUCCESS
    try:
        self.callbacks.remove_action(action_name)
    except KeyError as error:
        self.logger.error(str(error))
        status = constants.STATUS_NOT_FOUND
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.action_progress_update">
    <p>def <span class="ident">action_progress_update</span>(</p><p>self, request_id, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Update message for action (method) request in Cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.action_progress_update', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.action_progress_update" class="source">
    <pre><code>def action_progress_update(self, request_id, message):
    """
    Update message for action (method) request in Cloud
    """
    cmd = tr50.create_mailbox_update(request_id, message)
    message = defs.OutMessage(cmd, "Update Action Progress "
                              "{} \"{}\"".format(request_id, message))
    return self.send(message)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.action_register_callback">
    <p>def <span class="ident">action_register_callback</span>(</p><p>self, action_name, callback_function, user_data=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Associate a callback function with an action in the Cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.action_register_callback', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.action_register_callback" class="source">
    <pre><code>def action_register_callback(self, action_name, callback_function,
                             user_data=None):
    """
    Associate a callback function with an action in the Cloud
    """
    status = constants.STATUS_SUCCESS
    action = defs.Action(action_name, callback_function, self.client,
                         user_data=user_data)
    try:
        self.callbacks.add_action(action)
        self.logger.info("Registered action \"%s\" with function \"%s\"",
                         action_name, callback_function.__name__)
    except KeyError as error:
        self.logger.error("Failed to register action. %s", str(error))
        status = constants.STATUS_EXISTS
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.action_register_command">
    <p>def <span class="ident">action_register_command</span>(</p><p>self, action_name, command)</p>
    </div>
    

    
  
    <div class="desc"><p>Associate a console command with an action in the Cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.action_register_command', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.action_register_command" class="source">
    <pre><code>def action_register_command(self, action_name, command):
    """
    Associate a console command with an action in the Cloud
    """
    status = constants.STATUS_SUCCESS
    action = defs.ActionCommand(action_name, command, self.client)
    try:
        self.callbacks.add_action(action)
        self.logger.info("Registered action \"%s\" with command \"%s\"",
                         action_name, command)
    except KeyError as error:
        self.logger.error("Failed to register action. %s", str(error))
        status = constants.STATUS_EXISTS
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.calc_file_checksum">
    <p>def <span class="ident">calc_file_checksum</span>(</p><p>self, file_name)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate the crc32 checksum on a file and return the string
interpretation of it.  Checksum of None means it failed.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.calc_file_checksum', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.calc_file_checksum" class="source">
    <pre><code>def calc_file_checksum(self, file_name):
    """
    Calculate the crc32 checksum on a file and return the string
    interpretation of it.  Checksum of None means it failed.
    """
    sample = 0
    checksum = None
    if os.path.exists(file_name):
        for chunk in open(file_name, "rb"):
            sample = crc32(chunk, sample)
        checksum = "%s" % (sample & 0xffffffff)
    return checksum
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.connect">
    <p>def <span class="ident">connect</span>(</p><p>self, timeout=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Connect to MQTT and start main thread</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.connect', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.connect" class="source">
    <pre><code>def connect(self, timeout=0):
    """
    Connect to MQTT and start main thread
    """
    self.to_quit = False
    status = constants.STATUS_FAILURE
    result = -1
    # Ensure we have a host and port to connect to
    if not self.config.cloud.host or not self.config.cloud.port:
        self.logger.error("Missing host or port from configuration")
        status = constants.STATUS_BAD_PARAMETER
    else:
        current_time = datetime.utcnow()
        end_time = current_time + timedelta(seconds=timeout)
        self.state = constants.STATE_CONNECTING
        # Add network check and poll here while it is not
        # available.  Otherwise, the service will exit which is
        # not ideal if you do not have a service monitor like
        # systemd.
        test_network = True
        self.logger.info("Checking for network connectivity...")
        while test_network:
            try:
                ret = socket.gethostbyname(self.config.cloud.host)
                if ret:
                    self.logger.info("Network is active" )
                    test_network = False
            except socket.error as err:
                self.logger.error("Network error detected: %s" % str(err))
                sleep(1)
        # Start a secure connection if using a secure port and the cert file
        # is available
        if self.config.cloud.port in constants.SECURE_PORTS:
            if self.config.validate_cloud_cert is False:
                context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
                context.verify_mode = ssl.CERT_NONE
                context.check_hostname = False
                self.mqtt.tls_set_context(context)
            elif not self.config.ca_bundle_file:
                self.logger.error("Missing certificate bundle from configuration")
                status = constants.STATUS_BAD_PARAMETER
            elif not os.path.isfile(self.config.ca_bundle_file):
                self.logger.error("Certificate bundle not found")
                status = constants.STATUS_NOT_FOUND
            else:
                context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
                context.load_verify_locations(cafile=self.config.ca_bundle_file)
                context.verify_mode = ssl.CERT_REQUIRED
                context.check_hostname = True
                self.mqtt.tls_set_context(context)
        # status != bad_parameter or not_found
        if status == constants.STATUS_FAILURE:
            # Start MQTT connection
            try:
                result = self.mqtt.connect(self.config.cloud.host,
                                           self.config.cloud.port, 60)
            except Exception as error:
                # socket.gaierror or ssl.SSLError
                self.state = constants.STATE_DISCONNECTED
                self.logger.error(str(error))
    if result == 0:
        # Successful MQTT connection
        self.logger.info("Connecting...")
        # Start main loop thread so that MQTT can make the on_connect
        # callback
        self.main_thread = threading.Thread(target=self.main_loop)
        self.main_thread.start()
        # Wait for cloud connection
        while ((timeout == 0 or current_time < end_time) and
               self.state == constants.STATE_CONNECTING):
            sleep(0.1)
            current_time = datetime.utcnow()
        # Still connecting, timed out
        if self.state == constants.STATE_CONNECTING:
            self.logger.error("Connection timed out")
            status = constants.STATUS_TIMED_OUT
    if self.state == constants.STATE_CONNECTED:
        # Connected Successfully
        status = constants.STATUS_SUCCESS
        # Start worker threads if we have successfully connected
        for _ in range(self.config.thread_count):
            self.worker_threads.append(threading.Thread(
                target=self.handle_work_loop))
        for thread in self.worker_threads:
            thread.start()
    else:
        # Not connected. Stop main loop.
        self.logger.error("Failed to connect")
        self.to_quit = True
        self.state = constants.STATE_DISCONNECTED
        if self.main_thread:
            self.main_thread.join()
            self.main_thread = None
    # Return result of connection
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.disconnect">
    <p>def <span class="ident">disconnect</span>(</p><p>self, wait_for_replies=False, timeout=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Stop threads and shut down MQTT client</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.disconnect', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.disconnect" class="source">
    <pre><code>def disconnect(self, wait_for_replies=False, timeout=0):
    """
    Stop threads and shut down MQTT client
    """
    current_time = datetime.utcnow()
    end_time = current_time + timedelta(seconds=timeout)
    # Publish any data that was queued before disconnecting
    if not self.publish_queue.empty():
        self.queue_work(defs.Work(constants.WORK_PUBLISH, None))
    # Wait for pending work that has not been dealt with
    self.logger.info("Disconnecting...")
    while ((timeout == 0 or current_time < end_time) and
           not self.work_queue.empty()):
        sleep(0.1)
        current_time = datetime.utcnow()
    # Optionally wait for any outstanding replies.
    if wait_for_replies and self.is_connected():
        self.logger.info("Waiting for replies...")
        while ((timeout == 0 or current_time < end_time) and
               len(self.reply_tracker) != 0):
            sleep(0.1)
            current_time = datetime.utcnow()
    self.to_quit = True
    #TODO: Kill any hanging threads
    if threading.current_thread() not in self.worker_threads:
        if self.main_thread:
            self.main_thread.join()
            self.main_thread = None
    return constants.STATUS_SUCCESS
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.do_file_get">
    <p>def <span class="ident">do_file_get</span>(</p><p>self, url, validate, file_xfer_obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Perform a get on the specified file.  Handle all errors and
exceptions and resumuption from where the download left off.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.do_file_get', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.do_file_get" class="source">
    <pre><code>def do_file_get(self, url, validate, file_xfer_obj):
    """
    Perform a get on the specified file.  Handle all errors and
    exceptions and resumuption from where the download left off.
    """
    response = None
    # -------------------------------------------------------
    # Resume download:
    # -the .part file should exist, but if it doesn't force a
    # clean download
    # -for resume, set the Range header for resume
    # -set the file args to append or overwrite mode
    # -------------------------------------------------------
    if file_xfer_obj.resume_download and os.path.exists(file_xfer_obj.download_temp_path):
        resume_from = os.path.getsize(file_xfer_obj.download_temp_path)
        hdrs = {'Range':'bytes=%s-' % resume_from}
        self.logger.info("Resuming download of %s from %d bytes",
            file_xfer_obj.download_temp_path, resume_from )
        file_args = "ab"
    else:
        hdrs = {}
        file_args = "wb"
    # ---------------------------------------------------------
    # Downloading:
    # -start the download, validate and check use a connectivity
    # timeout so that we can quickly be notified and retry
    # -iterate and write chunks to file
    # -print out progress % but throttle it so that it doesn't
    # overwhelm the system, e.g. progress % 100 == 0
    # -crc32 must be added intrementally and compared later
    # -handle connection and http exceptions
    # -make sure not to retry on http errors > 400
    # -throttle printouts
    # ---------------------------------------------------------
    proxies = self.get_proxy_settings()
    response = requests.get(url, stream=True, verify=validate, timeout=3,
         headers=hdrs, proxies=proxies)
    self.logger.debug("HTTP Status %s" % response.status_code)
    if response.status_code == 200 or response.status_code == 206:
        count = 0
        download_len = 0
        chunk_size = 4096
        with open(file_xfer_obj.download_temp_path, file_args) as temp_file:
            try:
                for chunk in response.iter_content(chunk_size):
                    if not chunk:
                        break
                    temp_file.write(chunk)
                    if count % 100 == 0:
                        download_len = int(os.path.getsize(file_xfer_obj.download_temp_path))
                        progress = 100 * (float(download_len)/file_xfer_obj.file_size)
                        self.logger.debug("Download progress %0.2f(%%)",
                             float(progress))
                    count +=1
            except (Exception) as e:
                self.logger.error("Exception: %s",str(e))
        response.close()
        temp_file.close()
        # -------------------------------------------------------------
        # Validation phase:
        # -if checksums match, move/rename temporary file to real file name
        # Windows requires the target file to be removed if it
        # exists
        # -if the file size is not correct, retry
        # -if the checksum is not correct, fatal, meaning we
        # downloaded everything correctly but the file content is not
        # correct.  No way to recover, just return failure.
        # -------------------------------------------------------------
        checksum = self.calc_file_checksum(file_xfer_obj.download_temp_path)
        self.logger.debug("Checksum calculated=%s, checksum expected %s",
            checksum, file_xfer_obj.file_checksum)
        if (file_xfer_obj.file_checksum == None) or (checksum == str(file_xfer_obj.file_checksum)):
            self.logger.info("Checksum is correct")
            try:
                os.rename(file_xfer_obj.download_temp_path, file_xfer_obj.file_path)
            except:
                os.remove(file_xfer_obj.file_path)
                os.rename(file_xfer_obj.download_temp_path, file_xfer_obj.file_path)
            self.logger.info("Successfully downloaded %s", file_xfer_obj.file_name)
            status = constants.STATUS_SUCCESS
        elif download_len != file_xfer_obj.file_size:
            self.logger.error("Download was interrupted, trying again")
            status = constants.STATUS_TRY_AGAIN
        else:
            self.logger.error("Fatal error: download completed but checksum"
               " does not match expected.  Deleting file.")
            os.remove(file_xfer_obj.download_temp_path)
            status = constants.STATUS_FAILURE
    elif response.status_code >= 400:
        self.logger.error("A fatal HTTP error occurred: %s", response.reason)
        status = constants.STATUS_FAILURE
    else:
        self.logger.error("File transfer interrupted.  Trying again.")
        status = constants.STATUS_TRY_AGAIN
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.get_proxy_settings">
    <p>def <span class="ident">get_proxy_settings</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.get_proxy_settings', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.get_proxy_settings" class="source">
    <pre><code>def get_proxy_settings(self):
    if self.config.proxy:
        self.logger.debug("Proxy support detected")
        self.logger.debug("\ttype {} host {} port {}"
            .format(self.config.proxy.type,
            self.config.proxy.host,
            str(self.config.proxy.port )))
        proxy_host = self.config.proxy.host + ':' + str(self.config.proxy.port)
        proxy_type = self.config.proxy.type.lower()
        proxy_auth = ""
        # setup auth
        if self.config.proxy.username:
            proxy_auth = self.config.proxy.username
        if self.config.proxy.password:
            proxy_auth += ':' + self.config.proxy.password
            proxy_auth += '@'
        # key type is always http.  There is a bug when using
        # https.  The proxy tries to do a connect and fails with a
        # 403 error.
        proxies = {
            'http':  proxy_type + '://' + proxy_auth + proxy_host
        }
    else:
        proxies = None
    return proxies
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.handle_action">
    <p>def <span class="ident">handle_action</span>(</p><p>self, action_request)</p>
    </div>
    

    
  
    <div class="desc"><p>Handle action execution requests from Cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.handle_action', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.handle_action" class="source">
    <pre><code>def handle_action(self, action_request):
    """
    Handle action execution requests from Cloud
    """
    result_code = -1
    result_args = {"mail_id":action_request.request_id}
    action_result = None
    action_failed = False
    try:
        # Execute callback
        action_result = self.callbacks.execute_action(action_request)
    except Exception as error:
        # Error with action execution. Might not have been registered.
        action_failed = True
        self.logger.error("Action %s execution failed", action_request.name)
        self.logger.error(".... %s", str(error))
        result_code = constants.STATUS_FAILURE
        result_args["error_message"] = "ERROR: {}".format(str(error))
        if action_request.name not in self.callbacks:
            result_code = constants.STATUS_NOT_FOUND
        else:
            self.logger.exception("Exception:")
    # Action execution did not raise an error
    if not action_failed:
        # Handle returning a tuple or just a status code
        if action_result.__class__.__name__ == "tuple":
            result_code = action_result[0]
            if len(action_result) >= 2:
                result_args["error_message"] = str(action_result[1])
            if len(action_result) >= 3:
                result_args["params"] = action_result[2]
        else:
            result_code = action_result
        if not is_valid_status(result_code):
            # Returned 'status' is not a valid status
            error_string = ("Invalid return status: " +
                            str(result_code))
            self.logger.error(error_string)
            result_code = constants.STATUS_BAD_PARAMETER
            result_args["error_message"] = "ERROR: " + error_string
    # Return status to Cloud
    # Check for invoked status.  If so, return mail box update not
    # ack.  Ack is the final notification.  This breaks triggers
    # etc because it doesn't update the status.
    result_args["error_code"] = tr50.translate_error_code(result_code)
    if result_code == constants.STATUS_INVOKED:
            update_args = {"mail_id":action_request.request_id}
            update_args["message"] = "Invoked"
            mailbox_ack = tr50.create_mailbox_update(**update_args)
    else:
            mailbox_ack = tr50.create_mailbox_ack(**result_args)
    message_desc = "Action Complete \"{}\"".format(action_request.name)
    message_desc += " result : {}({})".format(result_code,
                                              status_string(result_code))
    if result_args.get("error_message"):
        message_desc += " \"{}\"".format(result_args["error_message"])
    if result_args.get("params"):
        message_desc += " \"{}\"".format(str(result_args["params"]))
    message = defs.OutMessage(mailbox_ack, message_desc)
    status = self.send(message)
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.handle_attribute_get">
    <p>def <span class="ident">handle_attribute_get</span>(</p><p>self, attribute_name)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.handle_attribute_get', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.handle_attribute_get" class="source">
    <pre><code>def handle_attribute_get(self, attribute_name ):
    command = tr50.create_attribute_current(self.config.key, attribute_name)
    message_desc = "Reading current attribute..."
    message = defs.OutMessage(command, message_desc)
    self.pub_wait = True
    status = self.send(message)
    value = None
    timestamp = None
    # Wait for response from sending to cloud
    while self.pub_wait:
        sleep(0.5)
    # Convert to return codes
    if self.pub_response:
        ret = constants.STATUS_SUCCESS
    else:
        ret = constants.STATUS_FAILURE
    # make sure the key exists or there will be a KeyError
    # exception
    if 'attribute_current_value' in self.response.keys():
        value = self.response['attribute_current_value']
    if 'attribute_current_timestamp' in self.response.keys():
        timestamp = self.response['attribute_current_timestamp']
    return ret, value, timestamp
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.handle_file_download">
    <p>def <span class="ident">handle_file_download</span>(</p><p>self, file_xfer_obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Handle any accepted C2D file transfers</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.handle_file_download', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.handle_file_download" class="source">
    <pre><code>def handle_file_download(self, file_xfer_obj):
    """
    Handle any accepted C2D file transfers
    """
    # -----------------------------------------------------------
    # File download handler:
    # -prepare for a file download, create temp file, make sure
    # all directories exist.
    # -call do_file_get in a loop unless we get a STATUS_FAILURE,
    # which means it is fatal.
    # -----------------------------------------------------------
    status = constants.STATUS_SUCCESS
    self.logger.info("Downloading \"%s\"", file_xfer_obj.file_name)
    self.logger.info("File size \"%d\"", file_xfer_obj.file_size)
    url = "https://{}/file/{}".format(self.config.cloud.host, file_xfer_obj.file_id)
    download_dir = os.path.dirname(file_xfer_obj.file_path)
    temp_file_name = "".join([random.choice("0123456789") for _ in range(10)])
    temp_file_name += ".part"
    temp_path = os.path.join(download_dir, temp_file_name)
    file_xfer_obj.download_temp_path = temp_path
    if not os.path.exists(download_dir):
        try:
            os.makedirs(download_dir)
        except OSError as err:
            self.logger.exception(err)
            status = constants.STATUS_BAD_PARAMETER
    elif not os.path.isdir(download_dir):
        self.logger.error("Failed to download %s (destination error)",
                          file_xfer_obj.file_name)
        status = constants.STATUS_IO_ERROR
    if status == constants.STATUS_SUCCESS:
        if (self.config.validate_cloud_cert is False or
                not self.config.ca_bundle_file or
                not os.path.isfile(self.config.ca_bundle_file)):
            validate = False
        else:
            validate = self.config.validate_cloud_cert
        # ----------
        # Retry loop
        # ----------
        status = self.do_file_get(url, validate, file_xfer_obj)
        while (status == constants.STATUS_TRY_AGAIN ):
            file_xfer_obj.resume_download = True
            status = self.do_file_get(url, validate, file_xfer_obj)
            sleep(1)
    file_xfer_obj.status = status
    file_xfer_obj.finish()
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.handle_file_upload">
    <p>def <span class="ident">handle_file_upload</span>(</p><p>self, upload)</p>
    </div>
    

    
  
    <div class="desc"><p>Handle any accepted D2C file transfers</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.handle_file_upload', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.handle_file_upload" class="source">
    <pre><code>def handle_file_upload(self, upload):
    """
    Handle any accepted D2C file transfers
    """
    #TODO: Timeout
    status = constants.STATUS_SUCCESS
    self.logger.info("Uploading \"%s\" as \"%s\"",
                     os.path.basename(upload.file_path), upload.file_name)
    # Start creating URL for file upload
    url = "https://{}/file/{}".format(self.config.cloud.host,
                                      upload.file_id)
    response = None
    proxies = self.get_proxy_settings()
    if os.path.exists(upload.file_path):
        # If file exists attempt upload
        with open(upload.file_path, "rb") as up_file:
            # Secure or insecure HTTPS Post
            if (self.config.validate_cloud_cert is False or
                    not self.config.ca_bundle_file):
                response = requests.post(url, data=up_file,
                verify=False, proxies=proxies)
            else:
                cert_location = self.config.ca_bundle_file
                response = requests.post(url, data=up_file,
                                         verify=cert_location,
                                         proxies=proxies)
        if response.status_code == 200:
            self.logger.info("Successfully uploaded \"%s\"",
                             upload.file_name)
            status = constants.STATUS_SUCCESS
        else:
            self.logger.error("Failed to upload \"%s\"",
                              upload.file_name)
            self.logger.debug(".... %s", response.content)
            status = constants.STATUS_FAILURE
    else:
        # File does not exist
        self.logger.error("Cannot find file \"%s\". Upload failed.",
                          upload.file_path)
        status = constants.STATUS_NOT_FOUND
    # Update file transfer status
    upload.status = status
    # Call callback if it exists
    upload.finish()
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.handle_message">
    <p>def <span class="ident">handle_message</span>(</p><p>self, mqtt_message)</p>
    </div>
    

    
  
    <div class="desc"><p>Handle messages received from Cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.handle_message', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.handle_message" class="source">
    <pre><code>def handle_message(self, mqtt_message):
    """
    Handle messages received from Cloud
    """
    status = constants.STATUS_NOT_SUPPORTED
    msg_json = mqtt_message.json
    if "notify/" in mqtt_message.topic:
        # Received a notification
        if mqtt_message.topic[len("notify/"):] == "mailbox_activity":
            # Mailbox activity, send a request to check the mailbox
            self.logger.info("Recevied notification of mailbox activity")
            mailbox_check = tr50.create_mailbox_check(auto_complete=False)
            to_send = defs.OutMessage(mailbox_check, "Mailbox Check")
            self.send(to_send)
            status = constants.STATUS_SUCCESS
    elif "reply/" in mqtt_message.topic:
        # Received a reply to a previous message
        topic_num = mqtt_message.topic[len("reply/"):]
        for command_num in msg_json:
            reply = msg_json[command_num]
            # Retrieve the sent message that this is a reply for, removing
            # it from being tracked
            self.lock.acquire()
            try:
                sent_message = self.reply_tracker.pop_message(topic_num,
                                                              command_num)
            except KeyError as error:
                self.logger.error(error.message)
                continue
            finally:
                self.lock.release()
            sent_command_type = sent_message.command.get("command")
            # Log success status of reply
            if reply.get("success"):
                self.logger.info("Received success for %s-%s - %s",
                                 topic_num, command_num, sent_message)
            else:
                self.logger.error("Received failure for %s-%s - %s",
                                  topic_num, command_num, sent_message)
                self.logger.error(".... %s", str(reply))
                if self.client.error_handler:
                    self.client.error_handler(
                    reply.get("errorCodes", []),
                    sent_message,
                    str(reply))
            # Return "success" status
            if self.pub_wait:
                if self.pub_topic == topic_num:
                    self.pub_response = reply.get("success")
                    self.pub_wait = False
                else:
                    self.pub_wait = self.pub_response = False
            # Check what kind of message this is a reply to
            if sent_command_type == TR50Command.file_get:
                # Recevied a reply for a file download request
                if reply.get("success"):
                    file_id = reply["params"].get("fileId")
                    file_checksum = reply["params"].get("crc32")
                    file_size = reply["params"].get("fileSize")
                    file_transfer = sent_message.data
                    file_transfer.file_id = file_id
                    file_transfer.file_checksum = file_checksum
                    file_transfer.file_size = file_size
                    work = defs.Work(constants.WORK_DOWNLOAD, file_transfer)
                    self.queue_work(work)
                else:
                    if -90008 in reply.get("errorCodes", []):
                        sent_message.data.status = constants.STATUS_NOT_FOUND
                    elif sent_message.data != None:
                        sent_message.data.status = constants.STATUS_FAILURE
            elif sent_command_type == TR50Command.file_put:
                # Received a reply for a file upload request
                if reply.get("success"):
                    file_id = reply["params"].get("fileId")
                    file_transfer = sent_message.data
                    file_transfer.file_id = file_id
                    work = defs.Work(constants.WORK_UPLOAD, file_transfer)
                    self.queue_work(work)
                else:
                    sent_message.data.status = constants.STATUS_FAILURE
            elif sent_command_type == TR50Command.mailbox_check:
                # Received a reply for a mailbox check
                if reply.get("success"):
                    try:
                        for mail in reply["params"]["messages"]:
                            mail_command = mail.get("command")
                            if mail_command == "method.exec":
                                # Action execute request in mailbox
                                mail_id = mail.get("id")
                                action_name = mail["params"].get("method")
                                action_params = mail["params"].get("params")
                                action_request = defs.ActionRequest(mail_id,
                                                                    action_name,
                                                                    action_params)
                                work = defs.Work(constants.WORK_ACTION,
                                                 action_request)
                                self.queue_work(work)
                    except:
                        pass
            elif sent_command_type == TR50Command.diag_time:
                # Recevied a reply for a ping request
                if reply.get("success"):
                    mill = reply["params"].get("time")
                    print (datetime.fromtimestamp(mill/1000.0))
                else:
                    if -90008 in reply.get("errorCodes", []):
                        sent_message.data.status = constants.STATUS_NOT_FOUND
                    else:
                        sent_message.data.status = constants.STATUS_FAILURE
            elif sent_command_type == TR50Command.diag_ping:
                # Recevied a reply for a ping request
                if reply.get("success"):
                   print ('*Connection Okay* \n')
                else:
                    if -90008 in reply.get("errorCodes", []):
                        sent_message.data.status = constants.STATUS_NOT_FOUND
                    else:
                        sent_message.data.status = constants.STATUS_FAILURE
            elif sent_command_type == TR50Command.property_current:
                # Recevied a reply for a ping request
                if reply.get("success"):
                   params = reply.get("params")
                   self.response['telemetry_current_value'] = params.get("value")
                   self.response['telemetry_current_timestamp'] = params.get("ts")
                else:
                    if -90008 in reply.get("errorCodes", []):
                        sent_message.data.status = constants.STATUS_NOT_FOUND
                    elif sent_message.data != None:
                        sent_message.data.status = constants.STATUS_FAILURE
            elif sent_command_type == TR50Command.attribute_current:
                # Recevied a reply for a ping request
                if reply.get("success"):
                   params = reply.get("params")
                   self.response['attribute_current_value']  = params.get("value")
                   self.response['attribute_current_timestamp']  = params.get("ts")
                else:
                    if -90008 in reply.get("errorCodes", []):
                        sent_message.data.status = constants.STATUS_NOT_FOUND
                    elif  sent_message.data != None:
                        sent_message.data.status = constants.STATUS_FAILURE
        status = constants.STATUS_SUCCESS
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.handle_ping">
    <p>def <span class="ident">handle_ping</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Request connection check</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.handle_ping', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.handle_ping" class="source">
    <pre><code>def handle_ping(self):
    """
    Request connection check
    """
    command = tr50.create_diag_ping()
    message_desc = "Connected"
    message = defs.OutMessage(command, message_desc)
    status = self.send(message)
    return constants.STATUS_SUCCESS
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.handle_publish">
    <p>def <span class="ident">handle_publish</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Publish any pending publishes in the publish queue, or the cloud logger</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.handle_publish', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.handle_publish" class="source">
    <pre><code>def handle_publish(self):
    """
    Publish any pending publishes in the publish queue, or the cloud logger
    """
    status = constants.STATUS_SUCCESS
    # Collect all pending publishes in publish queue
    to_publish = []
    while not self.publish_queue.empty():
        try:
            to_publish.append(self.publish_queue.get())
        except queue.Empty:
            break
    if to_publish:
        # If pending publishes are found, parse into list for sending
        messages = []
        batch = {}
        batch['PublishAlarm'] = []
        batch['PublishAttribute'] = []
        batch['PublishTelemetry'] = []
        batch['PublishLocation'] = []
        batch['PublishLog'] = []
        for pub in to_publish:
            message = None
            # ------------------
            # Alarms
            # ------------------
            if pub.type == "PublishAlarm":
                batch[pub.type].append(
                    tr50.create_alarm_batch_item(
                        pub.name,
                        pub.state,
                        pub.timestamp,
                        pub.message,
                        pub.republish))
            # ------------------
            # Attributes
            # ------------------
            elif pub.type == "PublishAttribute":
                batch[pub.type].append(
                    tr50.create_attribute_batch_item(
                        pub.name,
                        pub.value,
                        pub.timestamp))
            elif pub.type == "PublishTelemetry":
                batch[pub.type].append(
                    tr50.create_property_batch_item(
                        pub.name,
                        pub.value,
                        pub.timestamp ))
            # ------------------
            # Location
            # ------------------
            elif pub.type == "PublishLocation":
                batch[pub.type].append(
                    tr50.create_location_batch_item(
                        pub.latitude,
                        pub.longitude,
                        pub.heading,
                        pub.altitude,
                        pub.speed,
                        pub.accuracy,
                        pub.fix_type,
                        pub.timestamp))
            # ------------------
            # Event logs
            # ------------------
            elif pub.type == "PublishLog":
                command = tr50.create_log_publish(self.config.key,
                                                  pub.message,
                                                  timestamp=pub.timestamp)
                message_desc = "Log Publish {}".format(pub.message)
                message = defs.OutMessage(command, message_desc)
            if message:
                messages.append(message)
        # Send all publishes
        if messages:
            status = self.send(messages)
        # send out batches
        if batch['PublishAlarm']:
            timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
            command = tr50.create_alarm_publish(self.config.key,
                                                "alarm_batch",
                                                "Alarm Batch",
                                                timestamp=timestamp,
                                                republish=False,
                                                batch=True)
            message_desc = "Alarm Publish {}".format("alarm_batch")
            message_desc += " : \"{}\"".format("Alarm Batch")
            batch_msg = defs.OutMessage(command, message_desc)
            batch_msg.command['params']['state'] = 0
            batch_msg.command['params']['data'] = batch['PublishAlarm']
            status = self.send(batch_msg)
        if batch['PublishAttribute']:
            timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
            command = tr50.create_attribute_publish(self.config.key,
                                                    "attribute_batch",
                                                    "Attribute Batch",
                                                    timestamp=timestamp,
                                                    batch=True)
            message_desc = "Attribute Publish {}".format("attribute_batch")
            message_desc += " : \"{}\"".format("Attribute Batch")
            batch_msg = defs.OutMessage(command, message_desc)
            batch_msg.command['params']['data'] = batch['PublishAttribute']
            status = self.send(batch_msg)
        if batch['PublishLocation']:
            timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
            command = tr50.create_location_publish(self.config.key,
                                                    "location_batch",
                                                    "Location Batch",
                                                    timestamp=timestamp,
                                                    batch=True)
            message_desc = "Location Publish {}".format("location_batch")
            message_desc += " : \"{}\"".format("Location Batch")
            batch_msg = defs.OutMessage(command, message_desc)
            batch_msg.command['params']['data'] = batch['PublishLocation']
            status = self.send(batch_msg)
        if batch['PublishTelemetry']:
            timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ")
            command = tr50.create_property_publish(self.config.key,
                                                    "property_batch",
                                                    "Property Batch",
                                                    timestamp=timestamp,
                                                    batch=True)
            message_desc = "Property Publish {}".format("property_batch")
            message_desc += " : \"{}\"".format("Property Batch")
            batch_msgs = defs.OutMessage(command, message_desc)
            batch_msgs.command['params']['data'] =  batch['PublishTelemetry']
            status = self.send(batch_msgs)
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.handle_telemetry_get">
    <p>def <span class="ident">handle_telemetry_get</span>(</p><p>self, telem_name)</p>
    </div>
    

    
  
    <div class="desc"><p>Add data to publish queue and wait for cloud response</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.handle_telemetry_get', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.handle_telemetry_get" class="source">
    <pre><code>def handle_telemetry_get(self, telem_name ):
    """
    Add data to publish queue and wait for cloud response
    """
    command = tr50.create_property_get_current(self.config.key, telem_name)
    message_desc = "Reading current property..."
    message = defs.OutMessage(command, message_desc)
    self.pub_wait = True
    status = self.send(message)
    value = None
    timestamp = None
    # Wait for response from sending to cloud
    while self.pub_wait:
        sleep(0.5)
    # Convert to return codes
    if self.pub_response:
        ret = constants.STATUS_SUCCESS
    else:
        ret = constants.STATUS_FAILURE
    # make sure the key exists or there will be a KeyError
    # exception
    if 'telemetry_current_value' in self.response.keys():
        value = self.response['telemetry_current_value']
    if 'telemetry_current_timestamp' in self.response.keys():
        timestamp = self.response['telemetry_current_timestamp']
    return ret, value, timestamp
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.handle_time">
    <p>def <span class="ident">handle_time</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Request time from the cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.handle_time', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.handle_time" class="source">
    <pre><code>def handle_time(self):
    """
    Request time from the cloud
    """
    command = tr50.create_diag_time()
    message_desc = "Retrieving Time.."
    message = defs.OutMessage(command, message_desc)
    status = self.send(message)
    return constants.STATUS_SUCCESS
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.handle_update_thing_details">
    <p>def <span class="ident">handle_update_thing_details</span>(</p><p>self, name=None, description=None, iccid=None, esn=None, imei=None, meid=None, imsi=None, unset_fields=[])</p>
    </div>
    

    
  
    <div class="desc"><p>Request to update a things definition.  The thing key must be
immutable.  Friendly name and other non connectivity tracking
keys can be changed, e.g. name, description, ICCID, ESN, IMEI,
IMSI.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.handle_update_thing_details', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.handle_update_thing_details" class="source">
    <pre><code>def handle_update_thing_details(self, name=None, description=None,
                        iccid=None, esn=None, imei=None, meid=None,
                        imsi=None, unset_fields=[]):
    """
    Request to update a things definition.  The thing key must be
    immutable.  Friendly name and other non connectivity tracking
    keys can be changed, e.g. name, description, ICCID, ESN, IMEI,
    IMSI.
    """
    # if any of the default values are None, unset them in the
    # thing update. Support unsetting members in the thing
    # description.  Maybe remove the unsupported tunnel
    # fields from the thing description TBD.
    unset = []
    list_test = True
    if isinstance(unset_fields, list):
        print("unset_fields is a list of %d items" % len(unset_fields))
        if len(unset_fields) > 0:
            for v in unset_fields:
                unset.append(v)
    else:
        list_test = False
        status = constants.STATUS_PARSE_ERROR
    if list_test:
        command = tr50.create_thing_update(self.config.key, name,
                        description, iccid, esn, imei, meid, imsi,
                        unset)
        message_desc = "Update Thing Details"
        message = defs.OutMessage(command, message_desc)
        status = self.send(message)
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.handle_work_loop">
    <p>def <span class="ident">handle_work_loop</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Loop for worker threads to handle any items put on the work queue</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.handle_work_loop', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.handle_work_loop" class="source">
    <pre><code>def handle_work_loop(self):
    """
    Loop for worker threads to handle any items put on the work queue
    """
    # Continuously loop while connected
    while not self.to_quit:
        work = None
        try:
            work = self.work_queue.get(timeout=self.config.loop_time)
        except queue.Empty:
            pass
        # If work is retrieved from the queue, handle it based on type
        if work:
            try:
                if work.type == constants.WORK_MESSAGE:
                    self.handle_message(work.data)
                elif work.type == constants.WORK_PUBLISH:
                    self.handle_publish()
                elif work.type == constants.WORK_ACTION:
                    self.handle_action(work.data)
                elif work.type == constants.WORK_DOWNLOAD:
                    self.handle_file_download(work.data)
                elif work.type == constants.WORK_UPLOAD:
                    self.handle_file_upload(work.data)
            except Exception:
                # Print traceback, but don't kill thread
                self.logger.exception("Exception:")
    return constants.STATUS_SUCCESS
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.is_connected">
    <p>def <span class="ident">is_connected</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns connection status of Client to Cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.is_connected', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.is_connected" class="source">
    <pre><code>def is_connected(self):
    """
    Returns connection status of Client to Cloud
    """
    return self.state == constants.STATE_CONNECTED
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.log_level">
    <p>def <span class="ident">log_level</span>(</p><p>self, log_level=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Set Logging Level</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.log_level', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.log_level" class="source">
    <pre><code>def log_level(self, log_level=None):
    """
    Set Logging Level
    """
    if log_level:
        if log_level in ('CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'LOG', 'WARNING', 'ALL'):
            if log_level == 'ALL':
                log_number = getattr(logging, 'DEBUG')
                self.logger.setLevel(log_number)
                self.logger.warning("log_level set as 'ALL', DEBUG used as default")
            else:
                log_number = getattr(logging, log_level)
                self.logger.setLevel(log_number)
                self.logger.debug("log_level set as %s", log_level)
        else:
            self.logger.setLevel(logging.DEBUG)
            self.logger.warning("log_level not set or invalid, DEBUG used as default")
    # If no log_level set, set as DEBUG
    else:
        self.logger.setLevel(logging.DEBUG)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.main_loop">
    <p>def <span class="ident">main_loop</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Main loop for MQTT to send and receive messages, as well as queue work
for publishing and checking timeouts</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.main_loop', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.main_loop" class="source">
    <pre><code>def main_loop(self):
    """
    Main loop for MQTT to send and receive messages, as well as queue work
    for publishing and checking timeouts
    """
    # Continuously loop while connected or connecting
    while not self.to_quit:
        # If disconnected, attempt to reestablish connection
        if self.state == constants.STATE_DISCONNECTED:
            max_time = self.config.keep_alive
            elapsed_time = (datetime.utcnow() -
                            self.last_connected).total_seconds()
            if max_time == 0 or elapsed_time < max_time:
                try:
                    result = self.mqtt.reconnect()
                    if result == 0:
                        self.logger.debug("Reconnecting...")
                        self.state = constants.STATE_CONNECTING
                except Exception:
                    sleep(self.config.loop_time)
            else:
                self.logger.error("No connection after %d seconds, "
                                  "exiting...",
                                  self.config.keep_alive)
                self.to_quit = True
                break
        self.mqtt.loop(timeout=self.config.loop_time)
        # Make a work item to publish anything that's pending
        if not self.publish_queue.empty():
            self.queue_work(defs.Work(constants.WORK_PUBLISH, None))
    # One last loop to send out any pending messages
    self.mqtt.loop(timeout=0.1)
    # Disconnect MQTT
    self.mqtt.disconnect()
    # Wait for worker threads to finish.
    for thread in self.worker_threads:
        thread.join()
    self.worker_threads = []
    # On disconnect, show all messages that never received replies
    if len(self.reply_tracker) > 0:
        self.logger.error("These messages never received a reply:")
        for mid, message in self.reply_tracker.items():
            self.logger.error(".... %s - %s", mid,
                              message.description)
    return constants.STATUS_SUCCESS
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.num_unfinished">
    <p>def <span class="ident">num_unfinished</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get number of unfulfilled requests</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.num_unfinished', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.num_unfinished" class="source">
    <pre><code>def num_unfinished(self):
    """
    Get number of unfulfilled requests
    """
    return len(self.mqtt._out_messages)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.on_connect">
    <p>def <span class="ident">on_connect</span>(</p><p>self, mqtt, userdata, flags, rc)</p>
    </div>
    

    
  
    <div class="desc"><p>Callback when MQTT Client connects to Cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.on_connect', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.on_connect" class="source">
    <pre><code>def on_connect(self, mqtt, userdata, flags, rc):
    """
    Callback when MQTT Client connects to Cloud
    """
    unfinished = self.num_unfinished()
    if (unfinished > 0):
        self.logger.info("%s messages are pending..", unfinished)
    # Check connection result from MQTT
    self.logger.info("MQTT connected: %s", mqttlib.connack_string(rc))
    if rc == 0:
        self.state = constants.STATE_CONNECTED
    else:
        self.state = constants.STATE_DISCONNECTED
        self.last_connected = datetime.utcnow()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.on_disconnect">
    <p>def <span class="ident">on_disconnect</span>(</p><p>self, mqtt, userdata, rc)</p>
    </div>
    

    
  
    <div class="desc"><p>Callback when MQTT Client disconnects from Cloud</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.on_disconnect', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.on_disconnect" class="source">
    <pre><code>def on_disconnect(self, mqtt, userdata, rc):
    """
    Callback when MQTT Client disconnects from Cloud
    """
    if self.to_quit:
        self.logger.info("MQTT disconnected")
    else:
        self.logger.error("MQTT connection lost. Attempting to reconnect...")
        self.last_connected = datetime.utcnow()
    self.state = constants.STATE_DISCONNECTED
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.on_message">
    <p>def <span class="ident">on_message</span>(</p><p>self, mqtt, userdata, msg)</p>
    </div>
    

    
  
    <div class="desc"><p>Callback when MQTT Client receives a message</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.on_message', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.on_message" class="source">
    <pre><code>def on_message(self, mqtt, userdata, msg):
    """
    Callback when MQTT Client receives a message
    """
    message = defs.Message(msg.topic, json.loads(msg.payload.decode()))
    self.logger.debug("Received message on topic \"%s\"\n%s", msg.topic,
                      message)
    # Queue work to handle received message. Don't block main loop with this
    # task.
    work = defs.Work(constants.WORK_MESSAGE, message)
    self.queue_work(work)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.on_publish">
    <p>def <span class="ident">on_publish</span>(</p><p>self, mqtt, userdata, mid)</p>
    </div>
    

    
  
    <div class="desc"><p>Notify that a message has been published</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.on_publish', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.on_publish" class="source">
    <pre><code>def on_publish(self, mqtt, userdata, mid):
    """
    Notify that a message has been published
    """
    if self.reply_tracker != {}:
        topic_num = self.reply_tracker.pop_mid(mid)
        self.logger.debug("MQTT sent %s", topic_num)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.qos_level">
    <p>def <span class="ident">qos_level</span>(</p><p>self, qos_level=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Set QoS Level</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.qos_level', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.qos_level" class="source">
    <pre><code>def qos_level(self, qos_level=None):
    """
    Set QoS Level
    """
    if qos_level in range(0, 2):
        self.qos_level = qos_level
        self.logger.info("qos_level set as %s", self.qos_level)
    else:
        self.logger.warning("qos_level invalid or not set, 1 used as default")
        self.qos_level = 1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.queue_publish">
    <p>def <span class="ident">queue_publish</span>(</p><p>self, pub)</p>
    </div>
    

    
  
    <div class="desc"><p>Place pub in the publish queue</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.queue_publish', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.queue_publish" class="source">
    <pre><code>def queue_publish(self, pub):
    """
    Place pub in the publish queue
    """
    self.publish_queue.put(pub)
    return constants.STATUS_SUCCESS
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.queue_work">
    <p>def <span class="ident">queue_work</span>(</p><p>self, work)</p>
    </div>
    

    
  
    <div class="desc"><p>Place work in the work queue</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.queue_work', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.queue_work" class="source">
    <pre><code>def queue_work(self, work):
    """
    Place work in the work queue
    """
    self.work_queue.put(work)
    return constants.STATUS_SUCCESS
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.request_download">
    <p>def <span class="ident">request_download</span>(</p><p>self, file_name, file_dest, blocking=False, callback=None, timeout=0, file_global=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Request a C2D file transfer</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.request_download', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.request_download" class="source">
    <pre><code>def request_download(self, file_name, file_dest, blocking=False,
                     callback=None, timeout=0, file_global=False):
    """
    Request a C2D file transfer
    """
    current_time = datetime.utcnow()
    end_time = current_time + timedelta(seconds=timeout)
    self.logger.info("Request download of %s", file_name)
    # is file_dest the full path or the parent directory?
    if os.path.isdir(file_dest):
        file_dest = os.path.join(file_dest, file_name)
    # File Transfer object for tracking progress
    transfer = defs.FileTransfer(file_name, file_dest, self.client,
                                 callback=callback)
    # Generate and send message to request file transfer
    command = tr50.create_file_get(self.config.key, file_name, file_global)
    message = defs.OutMessage(command, "Download {}".format(file_name),
                              data=transfer)
    status = self.send(message)
    # If blocking is set, wait for result of file transfer
    if status == constants.STATUS_SUCCESS and blocking:
        while ((timeout == 0 or current_time < end_time) and
               transfer.status is None):
            sleep(0.1)
            current_time = datetime.utcnow()
        if transfer.status is None:
            status = constants.STATUS_TIMED_OUT
        else:
            status = transfer.status
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.request_publish">
    <p>def <span class="ident">request_publish</span>(</p><p>self, data, cloud_response)</p>
    </div>
    

    
  
    <div class="desc"><p>Add data to publish queue and wait for cloud response</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.request_publish', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.request_publish" class="source">
    <pre><code>def request_publish(self, data, cloud_response):
    """
    Add data to publish queue and wait for cloud response
    """
    current_time = datetime.utcnow()
    end_time = current_time + timedelta(seconds=15)
    timeout = False
    self.pub_wait = cloud_response
    status = self.queue_publish(data)
    if cloud_response:
        status = constants.STATUS_FAILURE
        # Wait for response from sending to cloud
        while self.pub_wait and not self.to_quit:
            current_time = datetime.utcnow()
            if (current_time > end_time):
                timeout = True
                break
            else:
                sleep(0.5)
        # Convert to return codes
        if self.pub_response:
            status = constants.STATUS_SUCCESS
        elif timeout:
            status = constants.STATUS_TIMED_OUT
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.request_upload">
    <p>def <span class="ident">request_upload</span>(</p><p>self, file_path, upload_name=None, blocking=False, callback=None, timeout=0, file_global=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Request a D2C file transfer</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.request_upload', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.request_upload" class="source">
    <pre><code>def request_upload(self, file_path, upload_name=None, blocking=False,
                   callback=None, timeout=0, file_global=False):
    """
    Request a D2C file transfer
    """
    status = constants.STATUS_SUCCESS
    current_time = datetime.utcnow()
    end_time = current_time + timedelta(seconds=timeout)
    transfer = None
    self.logger.info("Request upload of %s", file_path)
    # Path must be absolute
    if not os.path.isabs(file_path):
        self.logger.error("Path must be absolute \"%s\"", file_path)
        status = constants.STATUS_NOT_FOUND
    if status == constants.STATUS_SUCCESS:
        # Check if file exists
        if not os.path.isfile(file_path):
            # No file to upload
            self.logger.error("Cannot find file %s. "
                              "Upload cancelled.", file_path)
            status = constants.STATUS_NOT_FOUND
        else:
            transfer = None
            file_name = os.path.basename(file_path)
            if not upload_name:
                upload_name = file_name
            # Get file crc32 checksum
            checksum = 0
            with open(file_path, "rb") as up_file:
                for chunk in up_file:
                    checksum = crc32(chunk, checksum)
            checksum = checksum & 0xffffffff
            # File Transfer object for tracking progress
            transfer = defs.FileTransfer(upload_name, file_path,
                                         self.client,
                                         callback=callback)
            # Generate and send message to request file transfer
            command = tr50.create_file_put(self.config.key, upload_name,
                                           crc32=checksum,
                                           file_global=file_global)
            message_desc = "Upload {} as {}".format(file_name,
                                                    upload_name)
            message = defs.OutMessage(command, message_desc,
                                      data=transfer)
            status = self.send(message)
            # If blocking is set, wait for result of file transfer
            if status == constants.STATUS_SUCCESS and blocking:
                while ((timeout == 0 or current_time < end_time) and
                       not self.to_quit and transfer.status is None):
                    sleep(0.1)
                    current_time = datetime.utcnow()
                if transfer.status is None:
                    status = constants.STATUS_TIMED_OUT
                else:
                    status = transfer.status
    return status
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.Handler.send">
    <p>def <span class="ident">send</span>(</p><p>self, messages)</p>
    </div>
    

    
  
    <div class="desc"><p>Send commands to the Cloud, and track them to wait for replies</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.Handler.send', this);">Show source &equiv;</a></p>
  <div id="source-handler.Handler.send" class="source">
    <pre><code>def send(self, messages):
    """
    Send commands to the Cloud, and track them to wait for replies
    """
    status = constants.STATUS_FAILURE
    message_list = messages
    if messages.__class__.__name__ != "list":
        message_list = [messages]
    # Generate final request string
    payload = tr50.generate_request([x.command for x in message_list])
    # Lock to ensure all outgoing messages are tracked before handling
    # received messages
    self.lock.acquire()
    try:
        # Obtain new unused topic number
        while True:
            topic_num = "{:0>4}".format(self.topic_counter)
            self.topic_counter += 1
            if topic_num not in self.reply_tracker:
                break
        self.pub_topic = topic_num
        # -----------------------------------------------------
        # Send payload over MQTT
        # Add small delay here so that we don't cross the API/s
        # threshold
        # -----------------------------------------------------
        sleep(self.client.idle_sleep)
        result, mid = self.mqtt.publish("api/{}".format(topic_num),
                                        payload, qos = self.qos_level)
        # Track the topic this message will send on
        self.reply_tracker.add_mid(mid, topic_num)
        # Current timestamp to mark when message was sent
        current_time = datetime.utcnow()
        # Track each message
        for num, msg in enumerate(message_list):
            # Add timestamps and ids
            msg.timestamp = current_time
            msg.out_id = "{}-{}".format(topic_num, num+1)
            self.reply_tracker.add_message(msg)
            self.logger.info("MQTT queued %s-%d - %s\n%s", topic_num, num+1,
                             msg, json.dumps(msg.command, indent=2,
                                             sort_keys=True))
        status = constants.STATUS_SUCCESS
    finally:
        self.lock.release()
    return status
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="handler.Handler.callbacks" class="name">var <span class="ident">callbacks</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.client" class="name">var <span class="ident">client</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.config" class="name">var <span class="ident">config</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.last_connected" class="name">var <span class="ident">last_connected</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.lock" class="name">var <span class="ident">lock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.main_thread" class="name">var <span class="ident">main_thread</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.no_reply" class="name">var <span class="ident">no_reply</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.original_socket" class="name">var <span class="ident">original_socket</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.pub_topic" class="name">var <span class="ident">pub_topic</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.publish_queue" class="name">var <span class="ident">publish_queue</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.reply_tracker" class="name">var <span class="ident">reply_tracker</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.response" class="name">var <span class="ident">response</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.state" class="name">var <span class="ident">state</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.to_quit" class="name">var <span class="ident">to_quit</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.topic_counter" class="name">var <span class="ident">topic_counter</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.work_queue" class="name">var <span class="ident">work_queue</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.Handler.worker_threads" class="name">var <span class="ident">worker_threads</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="handler.socket" class="name">class <span class="ident">original_socket</span></p>
      
  
    <div class="desc"><p>A subclass of _socket.socket adding the makefile() method.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.socket', this);">Show source &equiv;</a></p>
  <div id="source-handler.socket" class="source">
    <pre><code>class socket(_socket.socket):

    """A subclass of _socket.socket adding the makefile() method."""

    __slots__ = ["__weakref__", "_io_refs", "_closed"]

    def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None):
        # For user code address family and type values are IntEnum members, but
        # for the underlying _socket.socket they're just integers. The
        # constructor of _socket.socket converts the given argument to an
        # integer automatically.
        _socket.socket.__init__(self, family, type, proto, fileno)
        self._io_refs = 0
        self._closed = False

    def __enter__(self):
        return self

    def __exit__(self, *args):
        if not self._closed:
            self.close()

    def __repr__(self):
        """Wrap __repr__() to reveal the real class name and socket
        address(es).
        """
        closed = getattr(self, '_closed', False)
        s = "<%s.%s%s fd=%i, family=%s, type=%s, proto=%i" \
            % (self.__class__.__module__,
               self.__class__.__qualname__,
               " [closed]" if closed else "",
               self.fileno(),
               self.family,
               self.type,
               self.proto)
        if not closed:
            try:
                laddr = self.getsockname()
                if laddr:
                    s += ", laddr=%s" % str(laddr)
            except error:
                pass
            try:
                raddr = self.getpeername()
                if raddr:
                    s += ", raddr=%s" % str(raddr)
            except error:
                pass
        s += '>'
        return s

    def __getstate__(self):
        raise TypeError("Cannot serialize socket object")

    def dup(self):
        """dup() -> socket object

        Duplicate the socket. Return a new socket object connected to the same
        system resource. The new socket is non-inheritable.
        """
        fd = dup(self.fileno())
        sock = self.__class__(self.family, self.type, self.proto, fileno=fd)
        sock.settimeout(self.gettimeout())
        return sock

    def accept(self):
        """accept() -> (socket object, address info)

        Wait for an incoming connection.  Return a new socket
        representing the connection, and the address of the client.
        For IP sockets, the address info is a pair (hostaddr, port).
        """
        fd, addr = self._accept()
        # If our type has the SOCK_NONBLOCK flag, we shouldn't pass it onto the
        # new socket. We do not currently allow passing SOCK_NONBLOCK to
        # accept4, so the returned socket is always blocking.
        type = self.type & ~globals().get("SOCK_NONBLOCK", 0)
        sock = socket(self.family, type, self.proto, fileno=fd)
        # Issue #7995: if no default timeout is set and the listening
        # socket had a (non-zero) timeout, force the new socket in blocking
        # mode to override platform-specific socket flags inheritance.
        if getdefaulttimeout() is None and self.gettimeout():
            sock.setblocking(True)
        return sock, addr

    def makefile(self, mode="r", buffering=None, *,
                 encoding=None, errors=None, newline=None):
        """makefile(...) -> an I/O stream connected to the socket

        The arguments are as for io.open() after the filename, except the only
        supported mode values are 'r' (default), 'w' and 'b'.
        """
        # XXX refactor to share code?
        if not set(mode) <= {"r", "w", "b"}:
            raise ValueError("invalid mode %r (only r, w, b allowed)" % (mode,))
        writing = "w" in mode
        reading = "r" in mode or not writing
        assert reading or writing
        binary = "b" in mode
        rawmode = ""
        if reading:
            rawmode += "r"
        if writing:
            rawmode += "w"
        raw = SocketIO(self, rawmode)
        self._io_refs += 1
        if buffering is None:
            buffering = -1
        if buffering < 0:
            buffering = io.DEFAULT_BUFFER_SIZE
        if buffering == 0:
            if not binary:
                raise ValueError("unbuffered streams must be binary")
            return raw
        if reading and writing:
            buffer = io.BufferedRWPair(raw, raw, buffering)
        elif reading:
            buffer = io.BufferedReader(raw, buffering)
        else:
            assert writing
            buffer = io.BufferedWriter(raw, buffering)
        if binary:
            return buffer
        text = io.TextIOWrapper(buffer, encoding, errors, newline)
        text.mode = mode
        return text

    if hasattr(os, 'sendfile'):

        def _sendfile_use_sendfile(self, file, offset=0, count=None):
            self._check_sendfile_params(file, offset, count)
            sockno = self.fileno()
            try:
                fileno = file.fileno()
            except (AttributeError, io.UnsupportedOperation) as err:
                raise _GiveupOnSendfile(err)  # not a regular file
            try:
                fsize = os.fstat(fileno).st_size
            except OSError:
                raise _GiveupOnSendfile(err)  # not a regular file
            if not fsize:
                return 0  # empty file
            blocksize = fsize if not count else count

            timeout = self.gettimeout()
            if timeout == 0:
                raise ValueError("non-blocking sockets are not supported")
            # poll/select have the advantage of not requiring any
            # extra file descriptor, contrarily to epoll/kqueue
            # (also, they require a single syscall).
            if hasattr(selectors, 'PollSelector'):
                selector = selectors.PollSelector()
            else:
                selector = selectors.SelectSelector()
            selector.register(sockno, selectors.EVENT_WRITE)

            total_sent = 0
            # localize variable access to minimize overhead
            selector_select = selector.select
            os_sendfile = os.sendfile
            try:
                while True:
                    if timeout and not selector_select(timeout):
                        raise _socket.timeout('timed out')
                    if count:
                        blocksize = count - total_sent
                        if blocksize <= 0:
                            break
                    try:
                        sent = os_sendfile(sockno, fileno, offset, blocksize)
                    except BlockingIOError:
                        if not timeout:
                            # Block until the socket is ready to send some
                            # data; avoids hogging CPU resources.
                            selector_select()
                        continue
                    except OSError as err:
                        if total_sent == 0:
                            # We can get here for different reasons, the main
                            # one being 'file' is not a regular mmap(2)-like
                            # file, in which case we'll fall back on using
                            # plain send().
                            raise _GiveupOnSendfile(err)
                        raise err from None
                    else:
                        if sent == 0:
                            break  # EOF
                        offset += sent
                        total_sent += sent
                return total_sent
            finally:
                if total_sent > 0 and hasattr(file, 'seek'):
                    file.seek(offset)
    else:
        def _sendfile_use_sendfile(self, file, offset=0, count=None):
            raise _GiveupOnSendfile(
                "os.sendfile() not available on this platform")

    def _sendfile_use_send(self, file, offset=0, count=None):
        self._check_sendfile_params(file, offset, count)
        if self.gettimeout() == 0:
            raise ValueError("non-blocking sockets are not supported")
        if offset:
            file.seek(offset)
        blocksize = min(count, 8192) if count else 8192
        total_sent = 0
        # localize variable access to minimize overhead
        file_read = file.read
        sock_send = self.send
        try:
            while True:
                if count:
                    blocksize = min(count - total_sent, blocksize)
                    if blocksize <= 0:
                        break
                data = memoryview(file_read(blocksize))
                if not data:
                    break  # EOF
                while True:
                    try:
                        sent = sock_send(data)
                    except BlockingIOError:
                        continue
                    else:
                        total_sent += sent
                        if sent < len(data):
                            data = data[sent:]
                        else:
                            break
            return total_sent
        finally:
            if total_sent > 0 and hasattr(file, 'seek'):
                file.seek(offset + total_sent)

    def _check_sendfile_params(self, file, offset, count):
        if 'b' not in getattr(file, 'mode', 'b'):
            raise ValueError("file should be opened in binary mode")
        if not self.type & SOCK_STREAM:
            raise ValueError("only SOCK_STREAM type sockets are supported")
        if count is not None:
            if not isinstance(count, int):
                raise TypeError(
                    "count must be a positive integer (got {!r})".format(count))
            if count <= 0:
                raise ValueError(
                    "count must be a positive integer (got {!r})".format(count))

    def sendfile(self, file, offset=0, count=None):
        """sendfile(file[, offset[, count]]) -> sent

        Send a file until EOF is reached by using high-performance
        os.sendfile() and return the total number of bytes which
        were sent.
        *file* must be a regular file object opened in binary mode.
        If os.sendfile() is not available (e.g. Windows) or file is
        not a regular file socket.send() will be used instead.
        *offset* tells from where to start reading the file.
        If specified, *count* is the total number of bytes to transmit
        as opposed to sending the file until EOF is reached.
        File position is updated on return or also in case of error in
        which case file.tell() can be used to figure out the number of
        bytes which were sent.
        The socket must be of SOCK_STREAM type.
        Non-blocking sockets are not supported.
        """
        try:
            return self._sendfile_use_sendfile(file, offset, count)
        except _GiveupOnSendfile:
            return self._sendfile_use_send(file, offset, count)

    def _decref_socketios(self):
        if self._io_refs > 0:
            self._io_refs -= 1
        if self._closed:
            self.close()

    def _real_close(self, _ss=_socket.socket):
        # This function should not reference any globals. See issue #808164.
        _ss.close(self)

    def close(self):
        # This function should not reference any globals. See issue #808164.
        self._closed = True
        if self._io_refs <= 0:
            self._real_close()

    def detach(self):
        """detach() -> file descriptor

        Close the socket object without closing the underlying file descriptor.
        The object cannot be used after this call, but the file descriptor
        can be reused for other purposes.  The file descriptor is returned.
        """
        self._closed = True
        return super().detach()

    @property
    def family(self):
        """Read-only access to the address family for this socket.
        """
        return _intenum_converter(super().family, AddressFamily)

    @property
    def type(self):
        """Read-only access to the socket type.
        """
        return _intenum_converter(super().type, SocketKind)

    if os.name == 'nt':
        def get_inheritable(self):
            return os.get_handle_inheritable(self.fileno())
        def set_inheritable(self, inheritable):
            os.set_handle_inheritable(self.fileno(), inheritable)
    else:
        def get_inheritable(self):
            return os.get_inheritable(self.fileno())
        def set_inheritable(self, inheritable):
            os.set_inheritable(self.fileno(), inheritable)
    get_inheritable.__doc__ = "Get the inheritable flag of the socket"
    set_inheritable.__doc__ = "Set the inheritable flag of the socket"
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#handler.socket">original_socket</a></li>
          <li>_socket.socket</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="handler.socket.proto" class="name">var <span class="ident">proto</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.socket.timeout" class="name">var <span class="ident">timeout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="handler.socket.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, family=&lt;AddressFamily.AF_INET: 2&gt;, type=&lt;SocketKind.SOCK_STREAM: 1&gt;, proto=0, fileno=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.socket.__init__', this);">Show source &equiv;</a></p>
  <div id="source-handler.socket.__init__" class="source">
    <pre><code>def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None):
    # For user code address family and type values are IntEnum members, but
    # for the underlying _socket.socket they're just integers. The
    # constructor of _socket.socket converts the given argument to an
    # integer automatically.
    _socket.socket.__init__(self, family, type, proto, fileno)
    self._io_refs = 0
    self._closed = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.socket.accept">
    <p>def <span class="ident">accept</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>accept() -&gt; (socket object, address info)</p>
<p>Wait for an incoming connection.  Return a new socket
representing the connection, and the address of the client.
For IP sockets, the address info is a pair (hostaddr, port).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.socket.accept', this);">Show source &equiv;</a></p>
  <div id="source-handler.socket.accept" class="source">
    <pre><code>def accept(self):
    """accept() -> (socket object, address info)
    Wait for an incoming connection.  Return a new socket
    representing the connection, and the address of the client.
    For IP sockets, the address info is a pair (hostaddr, port).
    """
    fd, addr = self._accept()
    # If our type has the SOCK_NONBLOCK flag, we shouldn't pass it onto the
    # new socket. We do not currently allow passing SOCK_NONBLOCK to
    # accept4, so the returned socket is always blocking.
    type = self.type & ~globals().get("SOCK_NONBLOCK", 0)
    sock = socket(self.family, type, self.proto, fileno=fd)
    # Issue #7995: if no default timeout is set and the listening
    # socket had a (non-zero) timeout, force the new socket in blocking
    # mode to override platform-specific socket flags inheritance.
    if getdefaulttimeout() is None and self.gettimeout():
        sock.setblocking(True)
    return sock, addr
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.socket.close">
    <p>def <span class="ident">close</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>close()</p>
<p>Close the socket.  It cannot be used after this call.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.socket.close', this);">Show source &equiv;</a></p>
  <div id="source-handler.socket.close" class="source">
    <pre><code>def close(self):
    # This function should not reference any globals. See issue #808164.
    self._closed = True
    if self._io_refs <= 0:
        self._real_close()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.socket.detach">
    <p>def <span class="ident">detach</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>detach() -&gt; file descriptor</p>
<p>Close the socket object without closing the underlying file descriptor.
The object cannot be used after this call, but the file descriptor
can be reused for other purposes.  The file descriptor is returned.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.socket.detach', this);">Show source &equiv;</a></p>
  <div id="source-handler.socket.detach" class="source">
    <pre><code>def detach(self):
    """detach() -> file descriptor
    Close the socket object without closing the underlying file descriptor.
    The object cannot be used after this call, but the file descriptor
    can be reused for other purposes.  The file descriptor is returned.
    """
    self._closed = True
    return super().detach()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.socket.dup">
    <p>def <span class="ident">dup</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>dup() -&gt; socket object</p>
<p>Duplicate the socket. Return a new socket object connected to the same
system resource. The new socket is non-inheritable.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.socket.dup', this);">Show source &equiv;</a></p>
  <div id="source-handler.socket.dup" class="source">
    <pre><code>def dup(self):
    """dup() -> socket object
    Duplicate the socket. Return a new socket object connected to the same
    system resource. The new socket is non-inheritable.
    """
    fd = dup(self.fileno())
    sock = self.__class__(self.family, self.type, self.proto, fileno=fd)
    sock.settimeout(self.gettimeout())
    return sock
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.socket.get_inheritable">
    <p>def <span class="ident">get_inheritable</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the inheritable flag of the socket</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.socket.get_inheritable', this);">Show source &equiv;</a></p>
  <div id="source-handler.socket.get_inheritable" class="source">
    <pre><code>def get_inheritable(self):
    return os.get_inheritable(self.fileno())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.socket.makefile">
    <p>def <span class="ident">makefile</span>(</p><p>self, mode=&#39;r&#39;, buffering=None)</p>
    </div>
    

    
  
    <div class="desc"><p>makefile(...) -&gt; an I/O stream connected to the socket</p>
<p>The arguments are as for io.open() after the filename, except the only
supported mode values are 'r' (default), 'w' and 'b'.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.socket.makefile', this);">Show source &equiv;</a></p>
  <div id="source-handler.socket.makefile" class="source">
    <pre><code>def makefile(self, mode="r", buffering=None, *,
             encoding=None, errors=None, newline=None):
    """makefile(...) -> an I/O stream connected to the socket
    The arguments are as for io.open() after the filename, except the only
    supported mode values are 'r' (default), 'w' and 'b'.
    """
    # XXX refactor to share code?
    if not set(mode) <= {"r", "w", "b"}:
        raise ValueError("invalid mode %r (only r, w, b allowed)" % (mode,))
    writing = "w" in mode
    reading = "r" in mode or not writing
    assert reading or writing
    binary = "b" in mode
    rawmode = ""
    if reading:
        rawmode += "r"
    if writing:
        rawmode += "w"
    raw = SocketIO(self, rawmode)
    self._io_refs += 1
    if buffering is None:
        buffering = -1
    if buffering < 0:
        buffering = io.DEFAULT_BUFFER_SIZE
    if buffering == 0:
        if not binary:
            raise ValueError("unbuffered streams must be binary")
        return raw
    if reading and writing:
        buffer = io.BufferedRWPair(raw, raw, buffering)
    elif reading:
        buffer = io.BufferedReader(raw, buffering)
    else:
        assert writing
        buffer = io.BufferedWriter(raw, buffering)
    if binary:
        return buffer
    text = io.TextIOWrapper(buffer, encoding, errors, newline)
    text.mode = mode
    return text
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.socket.sendfile">
    <p>def <span class="ident">sendfile</span>(</p><p>self, file, offset=0, count=None)</p>
    </div>
    

    
  
    <div class="desc"><p>sendfile(file[, offset[, count]]) -&gt; sent</p>
<p>Send a file until EOF is reached by using high-performance
os.sendfile() and return the total number of bytes which
were sent.
<em>file</em> must be a regular file object opened in binary mode.
If os.sendfile() is not available (e.g. Windows) or file is
not a regular file socket.send() will be used instead.
<em>offset</em> tells from where to start reading the file.
If specified, <em>count</em> is the total number of bytes to transmit
as opposed to sending the file until EOF is reached.
File position is updated on return or also in case of error in
which case file.tell() can be used to figure out the number of
bytes which were sent.
The socket must be of SOCK_STREAM type.
Non-blocking sockets are not supported.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.socket.sendfile', this);">Show source &equiv;</a></p>
  <div id="source-handler.socket.sendfile" class="source">
    <pre><code>def sendfile(self, file, offset=0, count=None):
    """sendfile(file[, offset[, count]]) -> sent
    Send a file until EOF is reached by using high-performance
    os.sendfile() and return the total number of bytes which
    were sent.
    *file* must be a regular file object opened in binary mode.
    If os.sendfile() is not available (e.g. Windows) or file is
    not a regular file socket.send() will be used instead.
    *offset* tells from where to start reading the file.
    If specified, *count* is the total number of bytes to transmit
    as opposed to sending the file until EOF is reached.
    File position is updated on return or also in case of error in
    which case file.tell() can be used to figure out the number of
    bytes which were sent.
    The socket must be of SOCK_STREAM type.
    Non-blocking sockets are not supported.
    """
    try:
        return self._sendfile_use_sendfile(file, offset, count)
    except _GiveupOnSendfile:
        return self._sendfile_use_send(file, offset, count)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="handler.socket.set_inheritable">
    <p>def <span class="ident">set_inheritable</span>(</p><p>self, inheritable)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the inheritable flag of the socket</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-handler.socket.set_inheritable', this);">Show source &equiv;</a></p>
  <div id="source-handler.socket.set_inheritable" class="source">
    <pre><code>def set_inheritable(self, inheritable):
    os.set_inheritable(self.fileno(), inheritable)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="handler.socket.family" class="name">var <span class="ident">family</span></p>
            

            
  
    <div class="desc"><p>Read-only access to the address family for this socket.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="handler.socket.type" class="name">var <span class="ident">type</span></p>
            

            
  
    <div class="desc"><p>Read-only access to the socket type.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
